<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="一、引言&amp;emsp;&amp;emsp;本文将学习文件系统的其它性质和文件的性质，将从stat函数开始，逐个学习stat结构和的每一个成员以了解文件的所有属性，学习修改这些属性的各个函数（更改所有者，更改权限等）和Unix文件系统的结构以及符号链接。">
<meta property="og:type" content="article">
<meta property="og:title" content="linux学习笔记(3)—文件与目录">
<meta property="og:url" content="http://example.com/2018/09/05/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/index.html">
<meta property="og:site_name" content="严薇南的博客">
<meta property="og:description" content="一、引言&amp;emsp;&amp;emsp;本文将学习文件系统的其它性质和文件的性质，将从stat函数开始，逐个学习stat结构和的每一个成员以了解文件的所有属性，学习修改这些属性的各个函数（更改所有者，更改权限等）和Unix文件系统的结构以及符号链接。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.1.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.2.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.3.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.4.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.5.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.6.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.7.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.8.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.9.PNG">
<meta property="article:published_time" content="2018-09-05T04:00:00.000Z">
<meta property="article:modified_time" content="2021-04-04T02:49:31.787Z">
<meta property="article:author" content="严薇南">
<meta property="article:tag" content="关键字">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.1.PNG">


<link rel="canonical" href="http://example.com/2018/09/05/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>linux学习笔记(3)—文件与目录 | 严薇南的博客</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">严薇南的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习过程中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">一、引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0stat%E3%80%81fstat%E3%80%81fstatat%E5%92%8Clstat"><span class="nav-number">2.</span> <span class="nav-text">二、函数stat、fstat、fstatat和lstat</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">三、文件类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7ID%E5%92%8C%E7%BB%84ID"><span class="nav-number">4.</span> <span class="nav-text">四、设置用户ID和组ID</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">5.</span> <span class="nav-text">五、文件访问权限</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%96%B0%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83"><span class="nav-number">6.</span> <span class="nav-text">六、新文件和目录的所有权</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%87%BD%E6%95%B0access%E5%92%8Cfaccessat"><span class="nav-number">7.</span> <span class="nav-text">七、函数access和faccessat</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%87%BD%E6%95%B0umask"><span class="nav-number">8.</span> <span class="nav-text">八、函数umask</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E5%87%BD%E6%95%B0chmod%E3%80%81fchmod%E5%92%8Cfchmodat"><span class="nav-number">9.</span> <span class="nav-text">九、函数chmod、fchmod和fchmodat</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E7%B2%98%E7%9D%80%E4%BD%8D"><span class="nav-number">10.</span> <span class="nav-text">十、粘着位</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E5%87%BD%E6%95%B0chown%E3%80%81fchown%E3%80%81fchownat%E5%92%8Clchown"><span class="nav-number">11.</span> <span class="nav-text">十一、函数chown、fchown、fchownat和lchown</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E9%95%BF%E5%BA%A6"><span class="nav-number">12.</span> <span class="nav-text">十二、文件长度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E6%88%AA%E6%96%AD"><span class="nav-number">13.</span> <span class="nav-text">十三、文件截断</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">14.</span> <span class="nav-text">十四、文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%9C%AA%E6%90%9E%E6%87%82"><span class="nav-number">14.1.</span> <span class="nav-text">具体未搞懂</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0link%E3%80%81linkat%E3%80%81unlink%E3%80%81unlinkat%E5%92%8Cremove"><span class="nav-number">15.</span> <span class="nav-text">十五、函数link、linkat、unlink、unlinkat和remove</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%85%AD%E3%80%81%E5%87%BD%E6%95%B0rename%E5%92%8Crenameat"><span class="nav-number">16.</span> <span class="nav-text">十六、函数rename和renameat</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%83%E3%80%81%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="nav-number">17.</span> <span class="nav-text">十七、符号链接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E5%85%AB%E3%80%81-%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">18.</span> <span class="nav-text">十八、    文件时间及相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9A%82%E6%97%B6%E5%BF%BD%E7%95%A5"><span class="nav-number">18.1.</span> <span class="nav-text">暂时忽略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B9%9D%E3%80%81-%E5%87%BD%E6%95%B0mkdir%E3%80%81mkdirat%E5%92%8Crmdir"><span class="nav-number">19.</span> <span class="nav-text">十九、    函数mkdir、mkdirat和rmdir</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8D%81%E3%80%81%E5%87%BD%E6%95%B0chdir%E3%80%81fchdir"><span class="nav-number">20.</span> <span class="nav-text">二十、函数chdir、fchdir</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81%E8%AE%BE%E5%A4%87%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6"><span class="nav-number">21.</span> <span class="nav-text">二十一、设备特殊文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E5%B0%8F%E7%BB%93"><span class="nav-number">22.</span> <span class="nav-text">二十二、小结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="严薇南"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">严薇南</p>
  <div class="site-description" itemprop="description">人生为棋，我为卒，行动虽缓，不曾后退半步</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ywngithub" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ywngithub" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/09/05/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="严薇南">
      <meta itemprop="description" content="人生为棋，我为卒，行动虽缓，不曾后退半步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="严薇南的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux学习笔记(3)—文件与目录
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-05 12:00:00" itemprop="dateCreated datePublished" datetime="2018-09-05T12:00:00+08:00">2018-09-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-04 10:49:31" itemprop="dateModified" datetime="2021-04-04T10:49:31+08:00">2021-04-04</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Linux学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>&emsp;&emsp;本文将学习文件系统的其它性质和文件的性质，将从stat函数开始，逐个学习stat结构和的每一个成员以了解文件的所有属性，学习修改这些属性的各个函数（更改所有者，更改权限等）和Unix文件系统的结构以及符号链接。<a id="more"></a></p>
<h1 id="二、函数stat、fstat、fstatat和lstat"><a href="#二、函数stat、fstat、fstatat和lstat" class="headerlink" title="二、函数stat、fstat、fstatat和lstat"></a>二、函数stat、fstat、fstatat和lstat</h1><p>&emsp;&emsp;①函数原型：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;stat.h&gt;  </span><br><span class="line">int stat(const char *restrict pathname, struct stat *restrict buf);  </span><br><span class="line">int fstat(int fd, struct stat *buf);  </span><br><span class="line">int lstat(const char *restrict pathname, struct stat *restrict buf;  </span><br><span class="line">int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);    </span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;所有4个函数的返回值：成功返回0，出错返回-1。<br>&emsp;&emsp; <strong>小知识：restrict是C99中一种类型限定符，作用是告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其它直接或间接的方式修改该对象的内容。</strong><br>&emsp;&emsp;②函数说明  </p>
<blockquote>
<p>1、 <strong>stat函数</strong> 将返回与此命名文件有关的信息结构。<br>2、 <strong>fstat函数</strong> 获得已在描述符fd上打开文件的有关信息。<br>3、 <strong>lstat函数</strong> 类似于stat,但当命名文件是一个符号链接时，lstat返回该符号链接的有关信息，而不是由该符号链接引用的文件信息。<br>4、 <strong>fstatat函数</strong> 为一个相对于当前打开目录(由fd参数指向)的路径名返回文件统计信息。<br>5、 <strong>buf是一个stat指针</strong> ，它指向一个已经定义的结构，函数将buf指向的结构进行填充，stat结构如下： </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct stat&#123;</span><br><span class="line">    mode_t              st_mode;  &#x2F;* file type &amp; mode (permissions) *&#x2F;</span><br><span class="line">    ino_t               st_ino;   &#x2F;* i-node number (serial number) *&#x2F;</span><br><span class="line">    dev_t               st_dev;   &#x2F;* device number (file system) *&#x2F;</span><br><span class="line">    nlink_t             st_rdev;  &#x2F;* device number for special files *&#x2F;</span><br><span class="line">    uid_t               st_uid;   &#x2F;* user ID of owner *&#x2F;</span><br><span class="line">    gid_t               st_gid;   &#x2F;* group ID of owner *&#x2F;</span><br><span class="line">    off_t               st_size;  &#x2F;* size in bytes, for regular files *&#x2F;</span><br><span class="line">    struct timespec     st_atime; &#x2F;* time of last access *&#x2F;</span><br><span class="line">    struct timespec     st_mtime; &#x2F;* time of last modification *&#x2F;</span><br><span class="line">    struct timespec     st_ctime; &#x2F;* time of last file status change *&#x2F;</span><br><span class="line">    blksize_t           st_blksize;&#x2F;* best I&#x2F;O block size *&#x2F;</span><br><span class="line">    blkcnt_t            st_blocks; &#x2F;* number of disk blocks allocated *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; <strong>timespec结构</strong> 按照 <strong>秒</strong> 和 <strong>纳秒</strong> 定义了时间，包含以下两个成员：</p>
<blockquote>
<p><strong>time_t tv_sec;</strong><br><strong>long tv_nsec;</strong>  </p>
</blockquote>
<p>&emsp;&emsp;使用stat最多的地方应该是ls -l，可以获得一个文件的所有信息。</p>
<h1 id="三、文件类型"><a href="#三、文件类型" class="headerlink" title="三、文件类型"></a>三、文件类型</h1><p>&emsp;&emsp;①文件类型</p>
<blockquote>
<p>1、 <strong>普通文件（regular file）</strong> ：最常用的文件类型，这种文件包含某种格式的数据，至于是文本或二进制数据，对于Unix内核而言并无区别，对普通文件内容的解析由处理该文件的应用程序进行（例外是二进制可执行文件，为了执行程序，内核必须解析二进制文件，因此所有二进制可执行文件都有一个标准格式，才能保证内核找到程序和数据的加载位置）。<br>2、 <strong>目录文件（directory file）</strong> ：目录其实也是一种文件，它包含了其它文件的名字以及指向这些文件有关信息的指针，任何具有读权限的进程都可以读取目录文件，但只有内核才可以直接写目录文件，进程必须使用特定函数才更改目录。<br>3、 <strong>块特殊文件（block special file）</strong> ：这种类型的文件提供对设备（如磁盘）带缓冲的访问，每次以固定的长度访问。<br>4、 <strong>字符特殊文件（block special file）</strong> ：这种类型的文件提供对设备不带缓冲的访问，每访问长度可变，系统中所有设备是块特殊文件或字符特殊文件。<br>5、 <strong>FIFO</strong>：这种类型的文件用于进程间通信，也被为命令管道。<br>6、 <strong>套接字（socket）</strong>：这种类型的文件用于进程间的网络通信。<br>7、 <strong>符号链接（symbolic link）</strong> ：这种类型的文件指向另一个文件。  </p>
</blockquote>
<p>&emsp;&emsp;②文件类型信息<br>&emsp;&emsp;包含在stat结构中的st_mode成员中，用下图中的宏来确定文件类型。</p>
<p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.1.PNG" alt="图片"></p>
<p>&emsp;&emsp;③实例程序：读取命令行，对每一个命令行参数打印其文件类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;   </span><br><span class="line">    int i; </span><br><span class="line">    struct stat buf;</span><br><span class="line">    char *ptr;</span><br><span class="line">    for(i&#x3D;1; i&lt;argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         printf(&quot;%s:&quot;,argv[i]);</span><br><span class="line">        if(lstat(argv[i], &amp;buf) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            err_ret(&quot;lstat error&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(S_ISREG(buf.st_mode))</span><br><span class="line">            ptr &#x3D; &quot;regular&quot;;</span><br><span class="line">         else if(S_ISDIR(buf.st_mode))</span><br><span class="line">            ptr &#x3D; &quot;directory&quot;;</span><br><span class="line">        else if(S_ISCHR(buf.st_mode))</span><br><span class="line">            ptr &#x3D; &quot;character special&quot;;</span><br><span class="line">        else if(S_ISBLK(buf.st_mode))</span><br><span class="line">            ptr &#x3D; &quot;block special&quot;;</span><br><span class="line">        else if(S_ISFIFO(buf.st_mode))</span><br><span class="line">            ptr &#x3D; &quot;fifo&quot;;</span><br><span class="line">        else if(S_ISLNK(buf.st_mode))</span><br><span class="line">            ptr &#x3D; &quot;symbolic link&quot;;</span><br><span class="line">         else if(S_ISSOCK(buf.st_mode))</span><br><span class="line">            ptr &#x3D; &quot;socket&quot;;</span><br><span class="line">        else</span><br><span class="line">            ptr &#x3D; &quot;unknow mode&quot;;</span><br><span class="line">         printf(&quot;%s\n&quot;,ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注释</strong>:<br>行10：使用stat函数获取文件信息，而不是stat的原因是以便检测符号链接。<br>行15-30：使用宏S_ISxxx检测是哪种类型的文件。  </p>
<p><strong>执行命令</strong>：<br>/a.out /etc/passwd /etc /dev/log /dev/tty /var/lib/oprofile/opd_pipe /dev/sr0 /dev/cdrom   </p>
<p><strong>结果</strong>：<br>/etc/passwd:regular<br>/etc:directory<br>/dev/log:symbolic link<br>/dev/tty:character special<br>/var/lib/oprofile/opd_pipe:lstat error: No such file or directory<br>/dev/sr0:block special<br>/dev/cdrom:symbolic link<br><strong>小知识：在命令行末端加入”&quot;可在第二行继续输入当前命令</strong>。  </p>
</blockquote>
<p>&emsp;&emsp;④不同类型文件的一个统计值</p>
<p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.2.PNG" alt="图片"></p>
<p>&emsp;&emsp;可见 <strong>普通文件</strong> 是最主要的类型。</p>
<h1 id="四、设置用户ID和组ID"><a href="#四、设置用户ID和组ID" class="headerlink" title="四、设置用户ID和组ID"></a>四、设置用户ID和组ID</h1><p>&emsp;&emsp;与一个进程相关联的ID有6个或更多（对于进程而言）：</p>
<p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.3.PNG" alt="图片"></p>
<blockquote>
<p>1、 <strong>实际用户ID和实际组ID</strong> ：取值为口令文件中的登录项，通常在一个登录会话期间这些值并不改变，但是超级用户进程可以改变（进程最初执行时所用ID）。<br>2、 <strong>有效用户ID、有效组ID和附属组ID</strong> ：进程执行时对文件的访问权限（进程实际执行中所用ID）。<br>3、 <strong>保存的设置用户ID和保存的设置组ID</strong> ：这个概念涉及到可执行程序文件的设置用户ID位，当可执行程序文件passwd的设置用户ID位(s)已经设置时，非root用户进程(exec)启动passwd程序，则该进程的有效用户ID和保存的设置用户ID都将被设置为这个可执行程序文件的所有者(即root)，也就是暂时可以用root的权限来访问文件了。<br>4、 <strong>通常有效用户ID等于实际用户ID，有效组ID等于实际组ID</strong> 。<br>5、 <strong>每个文件有一个所有者和组所有者，分别由st_uid和st_gid指定</strong> 。  </p>
</blockquote>
<h1 id="五、文件访问权限"><a href="#五、文件访问权限" class="headerlink" title="五、文件访问权限"></a>五、文件访问权限</h1><p>&emsp;&emsp;①    st_mode值（文件模式）包含了对文件的访问权限位（对于文件而言）：</p>
<p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.4.PNG" alt="图片"></p>
<blockquote>
<pre><code>1、当用路径访问一个文件时，每个目录都应该都具有执行权限。  
2、目录的执行权限与读权限有区别，读权限允许读目录获取该目录的所有文件列表，执行权限是要执行一个文件时，该文件所在目录需要的权限。  
3、对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作，这与open函数的O_RDONLY和O_RDWR标志有关。  
4、对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作，这与open函数的O_WRONLY和O_RDWR标志有关。  
5、为了在open函数中对一个文件指定O_TRUNC标志，必须对该文件具有写权限。  
6、为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限。  
7、问了在一个目录中删除一个文件，必须对包含该文件的目录具有写权限和执行权限，对该文件本身的权限并不关心。   
8、如果用7个exec函数中任何一个执行某文件，都必须对该文件具有执行权限，该文件必须是一个普通文件。  </code></pre>
</blockquote>
<p>&emsp;&emsp;②    进程每次打开、新建或删除一个文件时，内核将对该文件进行访问权限测试，文件的所有者（st_uid和st_gid）是文件的性质；有效用户ID、有效组ID和附属组ID则是进程的性质。</p>
<blockquote>
<pre><code>1、若进程的有效用户ID是0（即超级用户），则允许访问。  
2、若进程的有效用户ID等于文件所有者ID（即进程拥有此文件），那么如果所有者适当的访问权限位被设置，则允许访问，否则禁止访问。  
3、若进程的有效组ID或附属组ID之一等于文件的组ID，那么如果所有者适当的访问权限位被设置，则允许访问，否则禁止访问。  
4、若其它用户适当的访问权限位被设置，则允许访问，否则禁止访问。  </code></pre>
</blockquote>
<p>&emsp;&emsp;以上4个步骤顺序执行。  </p>
<h1 id="六、新文件和目录的所有权"><a href="#六、新文件和目录的所有权" class="headerlink" title="六、新文件和目录的所有权"></a>六、新文件和目录的所有权</h1><p>&emsp;&emsp;使用open和create函数创建新文件时，并没有设置文件的用户ID和组ID，以后学习mkdir函数时就会了解到如何创建一个新目录，并设置所有权规则。 <strong>新文件的用户ID将设置为进程的有效用户ID，而组ID将设置为进程的有效组ID或者它所在目录的组ID</strong>。</p>
<h1 id="七、函数access和faccessat"><a href="#七、函数access和faccessat" class="headerlink" title="七、函数access和faccessat"></a>七、函数access和faccessat</h1><p>&emsp;&emsp;当用open函数打开一个文件时，内核以进程的有效用户ID和有效组ID为基础进行访问测试，有时进程也希望按实际用户ID和实际组ID进行访问测试<br>&emsp;&emsp;①    函数作用：按实际用户ID和实际组ID进行访问测试。<br>&emsp;&emsp;②    函数原型：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int access(const char *pathname, int mode);</span><br><span class="line">int faccessat(int fd, const char *pathname, int mode, int flag);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回值：0-成功，-1-失败。  </p>
<blockquote>
<p><strong>mode参数</strong>：R_OK-测试读权限，W_OK-测试写权限，X_OK-测试执行权限。<br><strong>flag参数</strong>：改变faccessat的行为，取值为AT_EACCESS时，访问检查用的是调用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID。  </p>
</blockquote>
<h1 id="八、函数umask"><a href="#八、函数umask" class="headerlink" title="八、函数umask"></a>八、函数umask</h1><p>&emsp;&emsp;①    函数作用：每个文件都有9个访问权限位，为进程设置st_mode创建屏蔽字，并返回之前的值。<br>&emsp;&emsp;②    函数原型：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">mode_t umask(mode_t, cmask);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>cmask参数：由五①图中9个常量相”或”组成。</p>
</blockquote>
<p>&emsp;&emsp;③    程序示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &quot;fcntl.h&quot;</span><br><span class="line"></span><br><span class="line">#define RWRWRW (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    umask(0);</span><br><span class="line">    if(creat(&quot;foo&quot;, RWRWRW) &lt; 0)</span><br><span class="line">        err_sys(&quot;creat error for foo&quot;);</span><br><span class="line"></span><br><span class="line">    umask(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</span><br><span class="line">    if(creat(&quot;bar&quot;, RWRWRW) &lt; 0)</span><br><span class="line">        err_sys(&quot;creat error for foo&quot;);</span><br><span class="line"></span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>执行(%表示shell响应)：</strong>:<br>umask<br>%002  </p>
<p>./a.out<br>ls -l foo bar<br>%-rw——- 1 sar 0 dec 7 21:20 bar<br>%-rw-rw-rw- 1 sar 0 dec 7 21:20 foo  </p>
<p>umask<br>%002  </p>
</blockquote>
<p>&emsp;&emsp;④    umask文件访问权限位  </p>
<p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.5.PNG" alt="图片"></p>
<p>&emsp;&emsp;⑤    umask命令  </p>
<blockquote>
<p>umask–打印当前屏蔽字<br>umask -S–打印符号格式的屏蔽字<br>umask xxxx–修改屏蔽字  </p>
</blockquote>
<h1 id="九、函数chmod、fchmod和fchmodat"><a href="#九、函数chmod、fchmod和fchmodat" class="headerlink" title="九、函数chmod、fchmod和fchmodat"></a>九、函数chmod、fchmod和fchmodat</h1><p>&emsp;&emsp;①    函数作用：更改现有文件的访问权限。<br>&emsp;&emsp;②    函数原型：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int chmod(const char *pathname, mode_t mode);</span><br><span class="line">int fchmod(int fd, mode_t mode);</span><br><span class="line">int fchmodat(int fd, const char *pathname, mode_t mode, int flag);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回值：0-成功，-1-失败。  </p>
<blockquote>
<p><strong>参数mode</strong>：下图常量按位或</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.6.PNG" alt="图片"></p>
<h1 id="十、粘着位"><a href="#十、粘着位" class="headerlink" title="十、粘着位"></a>十、粘着位</h1><p>&emsp;&emsp;如果可执行程序的这一位被设置，那么该程序第一次被执行，在其终止时， <strong>程序正文（机器指令）的一个副本仍保存在交换区，使得下一次执行改程序时可以很快的载入内存</strong> ，因此称为”粘着”，也就有了 <strong>常量S_ISVTX</strong> ，但当今Unix系统大多数都配置了 <strong>虚拟存储系统</strong> 以及 <strong>快速文件系统</strong> ，因此不再需要使用这项技术。</p>
<h1 id="十一、函数chown、fchown、fchownat和lchown"><a href="#十一、函数chown、fchown、fchownat和lchown" class="headerlink" title="十一、函数chown、fchown、fchownat和lchown"></a>十一、函数chown、fchown、fchownat和lchown</h1><p>&emsp;&emsp;①    函数作用：更改文件的用户ID和组ID，如果参数owner和group有一个为-1，则对应的ID不变。<br>&emsp;&emsp;②    函数原型：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int chown(const char *path, uid_t owner, gid_t group);</span><br><span class="line">int fchown(int fd, uid_t owner, gid_t group);</span><br><span class="line">int lchown(const char *path, uid_t owner, gid_t group);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;返回值：0-成功，-1-失败。</p>
<h1 id="十二、文件长度"><a href="#十二、文件长度" class="headerlink" title="十二、文件长度"></a>十二、文件长度</h1><p>&emsp;&emsp;①    stat结构中的 <strong>成员st_size</strong> 表示单位为字节的文件长度，此字段只对 <strong>普通文件、目录文件和符号链接</strong> 有意义。</p>
<blockquote>
<p>1、 <strong>普通文件</strong>：文件长度可以是0，开始读这种文件时，将得到文件结束标志。<br>2、 <strong>目录文件</strong>：文件长度是16/512的整倍数。<br>3、 <strong>符号链接</strong>：文件长度等于路径名的字符长度。  </p>
</blockquote>
<p>&emsp;&emsp;②     大多数现代Unix系统提供字段 <strong>st_blksize和st_blocks</strong> ，前一个是指 <strong>对文件I/O较合适的块长度</strong> ，后一个是指 <strong>分配的实际512字节块数</strong>。</p>
<h1 id="十三、文件截断"><a href="#十三、文件截断" class="headerlink" title="十三、文件截断"></a>十三、文件截断</h1><p>&emsp;&emsp;有时需要在文件尾端处截去一些数据以缩短文件，将文件长度截断为0是一个特例，在打开文件时使用O_TRUNC可以实现这一点，为了截断文件可以使用函数truncate和fturncoat。<br>&emsp;&emsp;函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int truncate(const char *pathname, off_t length);</span><br><span class="line">int ftruncate(int fd, off_t length);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;函数作用：将一个现有文件长度截断为length，如果该文件以前长度大于length，则超过以外的数据就不能再访问，如果小于length，文件长度将增加，新增长度的数据为0。</p>
<h1 id="十四、文件系统"><a href="#十四、文件系统" class="headerlink" title="十四、文件系统"></a>十四、文件系统</h1><p>&emsp;&emsp;①    可以把一个磁盘分为一个或多个分区，每个分区可包含一个文件系统，i节点是固定长度的记录项，它包含有关文件的大部分信息，此磁盘、分区和文件系统以及具体的柱面组的i节点和数据块示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.7.PNG" alt="图片"><br><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.8.PNG" alt="图片"></p>
<p>&emsp;&emsp;②    <strong>i节点</strong> 包含了文件的所有信息，文件类型、文件访问权限位、文件长度和指向文件数据块的指针等，有两项数据存放在目录项中， <strong>文件名和i节点编号（数据类型为ino_t）</strong>。</p>
<p>&emsp;&emsp;③    对于Linux系统，链接分为两种，分别是硬链接和符号链接，默认ln命令产生硬链接。</p>
<blockquote>
<p><strong>硬链接</strong>：硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是 <strong>允许一个文件拥有多个有效路径名（在stat结构中，链接计数包含在st_nlink成员中，基本系统数据类型为nlink_t，LINK_MAX限制了链接数的最大值）</strong> ，这样用户就可以建立硬连接到重要文件，有防止 <strong>“误删”</strong> 的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。 <strong>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除</strong> 。</p>
</blockquote>
<blockquote>
<p><strong>符号链接</strong>：另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有 <strong>类似于Windows的快捷方式</strong> 。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p>
</blockquote>
<h2 id="具体未搞懂"><a href="#具体未搞懂" class="headerlink" title="具体未搞懂"></a><strong><em>具体未搞懂</em></strong></h2><h1 id="十五、函数link、linkat、unlink、unlinkat和remove"><a href="#十五、函数link、linkat、unlink、unlinkat和remove" class="headerlink" title="十五、函数link、linkat、unlink、unlinkat和remove"></a>十五、函数link、linkat、unlink、unlinkat和remove</h1><p>&emsp;&emsp;①link、linkat函数作用：创建一个指向现有文件的链接。<br>&emsp;&emsp;函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int link(const char *existingpath, const char *newpath);</span><br><span class="line">int linkat(int efd, const char *existingpath, const char *newpath, int flag);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;②unlink、unlinkat函数作用：删除一个现有的目录项。<br>&emsp;&emsp;函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int unlink(const char *pathname);</span><br><span class="line">int unlinkat(int fd, const char *pathname, int flag);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;③remove函数作用：解除对一个文件或目录的链接。<br>&emsp;&emsp;函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int remove(const char *pathname);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于文件–remove与unlink功能相同。<br>对于目录–remove与rmdir功能相同。</p>
</blockquote>
<p>&emsp;&emsp;④实例程序如下：打开一个文件，然后解除它的链接，睡眠15s后终止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    if(open(&quot;tempfile&quot;, O_RDWR) &lt; 0)</span><br><span class="line">        err_sys(&quot;open error&quot;);</span><br><span class="line">    if(unlink(&quot;tempfile&quot;) &lt; 0)</span><br><span class="line">        err_sys(&quot;unlink error&quot;);</span><br><span class="line">    printf(&quot;unlink ok\n&quot;);</span><br><span class="line">    sleep(15);</span><br><span class="line">    printf(&quot;done\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>执行(%表示shell响应)：</strong><br>ls -l tempfile    查看文件大小<br>%-rw-r–r– 1 yanwn yanwn 10974 9月   4 06:30 tempfile  </p>
<p>df /home    检查可用空间<br>%文件系统          1K-块    已用     可用 已用% 挂载点<br>%/dev/sda1      20509264 8004032 11440376   42% /  </p>
<p>./a.out &amp;    后台运行<br>%3088    进程号<br>% unlink ok  </p>
<p>ls -l tempfile    观察文件是否还存在<br>% ls: 无法访问’tempfile’: 没有那个文件或目录    目录项已经被删除  </p>
<p>df /home    再次检查可用空间<br>%文件系统          1K-块    已用     可用 已用% 挂载点<br>%/dev/sda1      20509264 8004032 11440376   42% /<br>%done    15s过后，进程结束  </p>
<p>df /home    最后检查可用空间<br>%文件系统          1K-块    已用     可用 已用% 挂载点<br>%/dev/sda1      20509264 8004024 11440384   42% /  </p>
</blockquote>
<p>&emsp;&emsp; <strong>分析：unlink这种特点经常用来确保程序崩溃时，它所创建的临时文件也不会被保存下来，进程用open或create创建一个文件，然后调用unlink，因为该文件是打开的，所以不会被删除，只有当进程关闭该文件或终止时（内核关闭该进程打开的所有文件），该文件的内容将会被清除。如果pathname是符号链接，那么unlink删除的是本身，而不是该链接指向的文件，任何函数都不能删除链接所指向的文件。</strong></p>
<h1 id="十六、函数rename和renameat"><a href="#十六、函数rename和renameat" class="headerlink" title="十六、函数rename和renameat"></a>十六、函数rename和renameat</h1><p>&emsp;&emsp;函数作用：对文件或目录重命名。<br>&emsp;&emsp;函数原型：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int rename(const char *oldname, const char *newname)</span><br><span class="line">int renameat(int oldfd, const char *oldname, int newfd, const char *newname);</span><br></pre></td></tr></table></figure>
<h1 id="十七、符号链接"><a href="#十七、符号链接" class="headerlink" title="十七、符号链接"></a>十七、符号链接</h1><p>&emsp;&emsp;①符号链接是一个文件的间接指针，以下为各个函数对符号链接的处理情况示意图：<br><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.9.PNG" alt="图片"></p>
<p>&emsp;&emsp;②函数symlink和symlinkat用于创建一个符号链接，readlink和readlinkat用于打开链接本身，并读取链接地址。<br>&emsp;&emsp;函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int symlink(const char*actualpath,const char *sympath);</span><br><span class="line">int symlinkat(const char *actualpath,int fd,const char *sympath);</span><br><span class="line">ssize_t readlink(const char* restrict pathname,char *restrict buf,size_t bufsize);</span><br><span class="line">ssize_t readlinkat(int fd,const char* restrict pathname,char *restrict buf,size_t bufsize);</span><br></pre></td></tr></table></figure>
<blockquote>
<pre><code>1、symlink函数创建了一个指向actualpath的新目录项sympath。在创建此符号链接时，并不要求actualpath已经存在。并且actualpath和sympath并不需要位于同一文件系统中。  
2、symlinkat函数与symlink函数类似，但sympath参数根据相对于打开文件描述符引用的目录(由fd指定)进行计算。如果sympath参数指定的是绝对路径或者fd参数设置了AT_FDCWD值，那么symlinkat就等同于symlink函数。  
3、readlink和readlinkat函数组合了open、read和close的所有操作。如果函数成功执行，则返回读入buf的字节数。在buf中返回的符号链接的内容不以null字符终止。  
4、当pathname参数指定的是绝对路径名或者fd参数的值为AT_FDCWD，readlinkat函数的行为与readlink相同。但是，如果fd参数是一个打开目录的有效文件描述符并且pathname参数是相对路径名，则readlinkat计算相对于由fd代表的打开目录的路径。  </code></pre>
</blockquote>
<h1 id="十八、-文件时间及相关函数"><a href="#十八、-文件时间及相关函数" class="headerlink" title="十八、    文件时间及相关函数"></a>十八、    文件时间及相关函数</h1><h2 id="暂时忽略"><a href="#暂时忽略" class="headerlink" title="暂时忽略"></a><strong><em>暂时忽略</em></strong></h2><h1 id="十九、-函数mkdir、mkdirat和rmdir"><a href="#十九、-函数mkdir、mkdirat和rmdir" class="headerlink" title="十九、    函数mkdir、mkdirat和rmdir"></a>十九、    函数mkdir、mkdirat和rmdir</h1><p>&emsp;&emsp;函数作用：mkdir、mkdirat用于创建目录，rmdir用于删除空目录。<br>&emsp;&emsp;函数原型：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int mkdir(const char *pathname, mode_t mode);</span><br><span class="line">int mkdirat(int fd, const char *pathname, mode_t mode);</span><br><span class="line">int rmdir(const char *pathname);</span><br></pre></td></tr></table></figure>

<h1 id="二十、函数chdir、fchdir"><a href="#二十、函数chdir、fchdir" class="headerlink" title="二十、函数chdir、fchdir"></a>二十、函数chdir、fchdir</h1><p>&emsp;&emsp;每个进程都有一个当前工作目录，当用户登录Unix系统时，其当前工作目录通常是口令文件（/etc/passwd）中登录项的第6个字段–用户的起始目录。 <strong>当前工作目录是进程的一个属性，起始目录是登录名的一个属性</strong> 。<br>&emsp;&emsp;函数作用：更改当前工作目录 <strong>（只影响调用进程的本身）</strong> 。<br>&emsp;&emsp;函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int chdir(constchar*pathname);</span><br><span class="line">int fchdir(int fd);</span><br></pre></td></tr></table></figure>

<h1 id="二十一、设备特殊文件"><a href="#二十一、设备特殊文件" class="headerlink" title="二十一、设备特殊文件"></a>二十一、设备特殊文件</h1><p>&emsp;&emsp;st_dev和st_rdev这两个字段容易混淆：</p>
<blockquote>
<p>1、每个文件系统所在的存储设备都由 <strong>主、次设备号</strong> 表示，设备号所用数据类型为dev_t, <strong>主设备号标识设备驱动程序，有时编码为与其通信的外设板，次设备标识特定的子设备</strong> ，一个磁盘驱动器通常包含多个文件系统，在同一磁盘上各文件系统的主设备号通常相同，但次设备号不同。<br>2、用 <strong>宏major和minor</strong> 来访问主、次设备号。<br>3、 <strong>系统中每个文件名关联的st_dev值是文件系统的设备号</strong> 。<br>4、 <strong>只有字符文件和块文件才有st_rdev值，此值包含实际设备的设备号</strong> 。  </p>
</blockquote>
<h1 id="二十二、小结"><a href="#二十二、小结" class="headerlink" title="二十二、小结"></a>二十二、小结</h1><p>&emsp;&emsp;本文围绕stat函数，学习了stat结构中的每一个成员，了解了Unix文件和目录的各个属性，学习了有关于文件和目录的大部分函数。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/09/02/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%B3%BB%E7%BB%9FIO/" rel="prev" title="linux学习笔记(2)—系统I/O">
                  <i class="fa fa-chevron-left"></i> linux学习笔记(2)—系统I/O
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/09/21/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%87%E5%87%86IO/" rel="next" title="linux学习笔记(4)—标准I/O">
                  linux学习笔记(4)—标准I/O <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">严薇南</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  





</body>
</html>
