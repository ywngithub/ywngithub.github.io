<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="一、引言&amp;emsp;&amp;emsp;本文学习标准I&#x2F;O库，不仅是Unix，很多其它操作系统都实现了标准I&#x2F;O，标准I&#x2F;O库处理了很多细节，如缓冲区分配，已优化的块长度执行I&#x2F;O等，用户无需担心使用正确的块长度，方便用户使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="linux学习笔记(4)—标准I&#x2F;O">
<meta property="og:url" content="http://example.com/2018/09/21/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%87%E5%87%86IO/index.html">
<meta property="og:site_name" content="严薇南的博客">
<meta property="og:description" content="一、引言&amp;emsp;&amp;emsp;本文学习标准I&#x2F;O库，不仅是Unix，很多其它操作系统都实现了标准I&#x2F;O，标准I&#x2F;O库处理了很多细节，如缓冲区分配，已优化的块长度执行I&#x2F;O等，用户无需担心使用正确的块长度，方便用户使用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.1.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.2.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.3.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.4.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.5.PNG">
<meta property="og:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.6.PNG">
<meta property="article:published_time" content="2018-09-21T13:58:07.000Z">
<meta property="article:modified_time" content="2021-04-04T02:49:18.068Z">
<meta property="article:author" content="严薇南">
<meta property="article:tag" content="关键字">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.1.PNG">


<link rel="canonical" href="http://example.com/2018/09/21/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%87%E5%87%86IO/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>linux学习笔记(4)—标准I/O | 严薇南的博客</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">严薇南的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习过程中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">一、引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%B5%81%E5%92%8CFILE%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.</span> <span class="nav-text">二、流和FILE对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E5%92%8C%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF"><span class="nav-number">3.</span> <span class="nav-text">三、标准输入、标准输出和标准错误</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%BC%93%E5%86%B2"><span class="nav-number">4.</span> <span class="nav-text">四、缓冲</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%89%93%E5%BC%80-%E5%85%B3%E9%97%AD%E6%B5%81"><span class="nav-number">5.</span> <span class="nav-text">五、打开&#x2F;关闭流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E8%AF%BB-%E5%86%99%E6%B5%81"><span class="nav-number">6.</span> <span class="nav-text">六、读&#x2F;写流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6I-O"><span class="nav-number">7.</span> <span class="nav-text">七、二进制I&#x2F;O</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%AE%9A%E4%BD%8D%E6%B5%81"><span class="nav-number">8.</span> <span class="nav-text">八、定位流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96I-O"><span class="nav-number">9.</span> <span class="nav-text">九、格式化I&#x2F;O</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E3%80%81%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">10.</span> <span class="nav-text">十、实现细节</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="nav-number">11.</span> <span class="nav-text">十一、临时文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E6%B5%81"><span class="nav-number">12.</span> <span class="nav-text">十二、内存流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%81%E4%B8%89%E3%80%81-%E5%B0%8F%E7%BB%93"><span class="nav-number">13.</span> <span class="nav-text">十三、    小结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="严薇南"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">严薇南</p>
  <div class="site-description" itemprop="description">人生为棋，我为卒，行动虽缓，不曾后退半步</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ywngithub" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ywngithub" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/09/21/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%87%E5%87%86IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="严薇南">
      <meta itemprop="description" content="人生为棋，我为卒，行动虽缓，不曾后退半步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="严薇南的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          linux学习笔记(4)—标准I/O
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-21 21:58:07" itemprop="dateCreated datePublished" datetime="2018-09-21T21:58:07+08:00">2018-09-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-04 10:49:18" itemprop="dateModified" datetime="2021-04-04T10:49:18+08:00">2021-04-04</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Linux学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>&emsp;&emsp;本文学习标准I/O库，不仅是Unix，很多其它操作系统都实现了标准I/O，标准I/O库处理了很多细节，如缓冲区分配，已优化的块长度执行I/O等，用户无需担心使用正确的块长度，方便用户使用。<a id="more"></a></p>
<h1 id="二、流和FILE对象"><a href="#二、流和FILE对象" class="headerlink" title="二、流和FILE对象"></a>二、流和FILE对象</h1><p>&emsp;&emsp;①对于标准I/O库而言，所有操作都围绕”流”进行，当用标准I/O库打开一个文件时，那么一个流将与一个文件关联。<br>&emsp;&emsp;②对于ASCII字符集，一个字符用一个字节表示，对于国际字符集（宽字符集），一个字符可用多个字节表示，标准I/O文件可用于单字符集或宽字符集，流的定向决定了所读、写的字符类型，当一个流初次创建时并没有被定向，只有两个函数可以改变流的定向：</p>
<blockquote>
<p>freopen函数清除一个流的定向。<br>fwide函数设置流的定向，不改变已定向的流。</p>
</blockquote>
<p>函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;wchar.h&gt;</span><br><span class="line">int fwide(FILE *fp, int mode);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mode&lt;0试图将流指定为字节定向。</p>
</blockquote>
<blockquote>
<p>mode=0不试图设置。   </p>
</blockquote>
<blockquote>
<p>mode&gt;0试图将流指定为宽定向。     </p>
</blockquote>
<p>&emsp;&emsp;③打开一个流时，标准I/O函数fopen返回一个FILE对象的指针，该对象通常是一个结构，包含了标准I/O库为管理该流需要的所有信息，包括用于实际I/O的文件描述符、指向用于该流缓冲的指针、缓冲区长度、当前在缓冲区中的字符数以及出错标志。<br>&emsp;&emsp;④为了引用一个流，需要将FILE指针作为参数传递给每个标准I/O函数，我们称指向FILE对象的指针（类型为FILE*）为文件指针。</p>
<h1 id="三、标准输入、标准输出和标准错误"><a href="#三、标准输入、标准输出和标准错误" class="headerlink" title="三、标准输入、标准输出和标准错误"></a>三、标准输入、标准输出和标准错误</h1><p>&emsp;&emsp;对一个进程预定义了三个流，分别是标准输入、标准输出和标准错误，这些流引用的文件与文件描述符STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO所引用的相同。<br>&emsp;&emsp;这三个标准I/O流通过预定义文件指针stdin、stdout和stderr加以引用，定义在&lt;stdio.h&gt;中。</p>
<h1 id="四、缓冲"><a href="#四、缓冲" class="headerlink" title="四、缓冲"></a>四、缓冲</h1><p>&emsp;&emsp;①标准I/O库提供缓冲的目的是尽可能的减少read和write调用的次数；还可以对每个I/O流自动的进行缓冲管理，从而避免应用程序考虑开辟缓冲区大小带来的麻烦。<br>&emsp;&emsp;②标准I/O库有三种缓冲：  </p>
<blockquote>
<p>全缓冲：填满标准I/O缓冲区才进行实际I/O操作，对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的，术语冲洗（flush）说明标准I/O缓冲区的写操作，可由标准I/O例程自动冲洗或者调用fflush函数冲洗一个流。<br>行缓冲：当在输入输出中遇到换行符时，标准I/O库执行I/O操作，只有写了一行之后才进行实际I/O操作，当流涉及一个终端（如标准输入和标准输出）时，通常使用行缓冲。<br>不带缓冲：标准错误stderr通常是不带缓冲的，可使得错误信息可以尽快的显示出来。  </p>
</blockquote>
<p>&emsp;&emsp;③函数setbuf和setvbuf<br>函数作用：更改缓冲类型/强制冲洗流。<br>函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void setbuf(FILE *restrict fp, char *restrict buf);</span><br><span class="line">void setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);</span><br><span class="line">int fflush(FILE *fp);</span><br></pre></td></tr></table></figure>
<p>函数说明：<br>setbuf函数打开或关闭缓冲机制，参数buf必须指向一个长度为BUFSIZ的缓冲区，一般而言该流被设置为全缓冲，为了关闭缓冲，将buf设置为NULL。使用setvbuf，可以精确地说明所需的缓冲类型，由mode参数指定，_IOFBF(全缓冲)，_IOLBF(行缓冲) ，_IONBF(无缓冲)，size参数指定长度。fflush函数用于强制冲洗一个流（所有未写的数据都被传送至内核）。</p>
<h1 id="五、打开-关闭流"><a href="#五、打开-关闭流" class="headerlink" title="五、打开/关闭流"></a>五、打开/关闭流</h1><p>&emsp;&emsp;①用下列3个函数打开一个标准I/O流：<br>函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">FILE *fopen(const char *restrict pathname, const char * restrict type);</span><br><span class="line">FILE *freopen(const char *restrict pathname, const char * restrict type, FILE * restrict fp);</span><br><span class="line">FILE *fdopen(int fd, const char *type);</span><br><span class="line">int fclose(FILE *fp);</span><br></pre></td></tr></table></figure>
<p>函数说明：<br>    fopen函数打开路径名为pathname的一个指定文件。<br>     freopen函数在一个指定的流上打开指定的文件，若该流已打开，则先关闭该流，若该流已定向，则使用freopen清除该定向，此函数一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出或标准错误。<br>     fdopen取一个已有的文件描述符（可能从open、dup、dup2、fcntl、pipe、socket、socketpair或accept函数得到此文件描述符），并使一个标准I/O流与该描述符相结合，此函数一般用于创建管道和网络通信函数返回的描述符，因为这些特殊文件不能用fopen打开。<br>     type参数如下图：<br> <img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.1.PNG" alt="图片"><br>使用字符b作为type的一部分，使得标准I/O系统可以区分文本文件和二进制文件，因为Unix系统并不对这两种文件进行区分，所以Unix系统环境指定b实际无作用。</p>
<h1 id="六、读-写流"><a href="#六、读-写流" class="headerlink" title="六、读/写流"></a>六、读/写流</h1><p>&emsp;&emsp;①每次一个字符的I/O</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int getc(FILE *fp);</span><br><span class="line">int fget(FILE *fp);</span><br><span class="line">int getchar(void); (&#x3D;getc(stdin))</span><br><span class="line"></span><br><span class="line">int putc(int c, FILE *fp);</span><br><span class="line">int fputc(int c, FILE *fp);</span><br><span class="line">int putchar(int c); (&#x3D;putc(int c, stdout))</span><br></pre></td></tr></table></figure>
<p>getc和fgetc的区别是前者可被实现为宏，后者不能，意味着fgetc可得到其函数地址，这就允许将fgetc的地址作为一个参数传送给另一个函数，调用fgetc时间比getc长，因为调用函数时间通常长于调用宏。注意不管出错还是到达文件尾端，这些函数都返回同样的值，为了区分这两种不同的情况，必须调用ferror和feof。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ferror(FILE *fp);</span><br><span class="line">int feof(FILE *fp);</span><br><span class="line">void clearer(FILE *fp);</span><br></pre></td></tr></table></figure>
<p>在大多数实现中，为每个流在FILE对象中维护了两个标志：</p>
<blockquote>
<p>出错标志<br>文件结束标志</p>
</blockquote>
<p>&emsp;&emsp;②每次一行的I/O</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char *fgets(char *restrict buf, int n, FILE *restrict fp);</span><br><span class="line">char *gets(char *buf);</span><br><span class="line"></span><br><span class="line">int fputs(const char *restrict str, FILE *restrict fp);</span><br><span class="line">int puts(const char *str);</span><br></pre></td></tr></table></figure>
<p>gets从标准输入读，而fgets从指定的流读，fgets必须指定缓冲的长度n，此函数一直读到下一个换行符为止，读入的字符被送入缓冲区，该缓冲区以null字节结尾。gets不推荐使用，因为不能指定缓冲区长度，这样就可能造成缓冲区溢出，gets和fgets的另一个区别是前者并不将换行符存入缓冲区中。</p>
<h1 id="七、二进制I-O"><a href="#七、二进制I-O" class="headerlink" title="七、二进制I/O"></a>七、二进制I/O</h1><p>&emsp;&emsp;上面函数以一次一个字符或一行的方式进行读写操作，如果进行二进制I/O操作，那么更希望一次读/写一个完整的结构，如果使用getc或putc读写一个结构，那么必须循环通过整个结构，每次循环处理一个字节，会很麻烦而且效率低，如果使用fputs和fgets，那么因为fputs遇到null字节就停止，而在结构中可能含有null字节，所以不能使用它实现读结构的要求，如果输入数据中含有null字节或换行符，则fgets也不能正常工作，因此提供下列函数执行二进制I/O操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);</span><br><span class="line">size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);</span><br></pre></td></tr></table></figure>
<h1 id="八、定位流"><a href="#八、定位流" class="headerlink" title="八、定位流"></a>八、定位流</h1><p>&emsp;&emsp;①方法1：ftell和fseek函数，他们都假设文件的位置可以存放在一个长整型中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long ftell(FILE *fp);</span><br><span class="line">int fseek(FILE *fp, long offset, int whence);</span><br><span class="line">void rewind(FILE *fp);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;对于一个二进制文件，其文件位置指示器从文件起始位置开始度量，并以字节为度量单位，ftell用于二进制文件时，返回的就是这种字节位置，为了用fseek定位一个二进制文件，必须指定一个字节offset，以及解释这种偏移量的方式。whence取值为：SEEK_SET表示从文件的起始位置开始，SEEK_CUR表示从当前文件位置开始，SEEK_END表示从文件尾端开始。<br>对于一个文本文件，文件位置不能用简单的字节偏移量来度量，因为在非Unix系统中，它们可能以不同的格式存放文本文件，为了定位一个文本文件，whence一定等于SEEK_SET，而且offset只有两种取值：0（后退至文件的起始位置），或是对该文件的ftell所返回的值。使用rewind函数也可以将一个流设置到文件的起始位置。<br>&emsp;&emsp;②方法2：除了偏移量类型是off_t而非long以外，ftello函数与ftell相同，fseeko函数与fseek相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">off_t ftello(FILE *fp);</span><br><span class="line">int fseeko(FILE *fp, off_t offset, int whence);</span><br></pre></td></tr></table></figure>
<p>可将off_set类型定义为长于32位。<br>&emsp;&emsp;③方法3：fgetpos和fsetpos两个函数是ISO C标准引入的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fgetpos(FILE *restrict fp, fpos_t *restrict pos);</span><br><span class="line">int fsetpos(FILE *fp, const fpos_t *pos);</span><br></pre></td></tr></table></figure>
<p>fgetpos将文件位置指示器的当前值存入由pos指向的对象中，在以后调用fsetpos时，可以使用此值将流重新定义到该位置。</p>
<h1 id="九、格式化I-O"><a href="#九、格式化I-O" class="headerlink" title="九、格式化I/O"></a>九、格式化I/O</h1><p>&emsp;&emsp;①格式化输出由5个printf函数处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int printf(const char *restrict format, …);</span><br><span class="line">int fprintf(FILE *restrict fp, const char *restrict format, …);</span><br><span class="line">int sprintf(char *restrict buf, const char *restrict format, …);</span><br><span class="line">int dprintf(int fd, const char *restrict format, …);</span><br><span class="line">int snprintf(char *restrict buf, size_t n, const char *restrict format, …);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;printf将格式化的数据写到标准输出，fprintf写至指定的流，dprintf写至指定的文件描述符，sprintf写至数组buf中，且在该数组的尾端自动添加一个null字节，该字符不包含在返回值中，为了防止buf缓冲区溢出，引入了snprintf函数，可指定长度n。  </p>
<p>&emsp;&emsp;format参数中，转换说明以%开始，除转换说明外，格式字符串中其它字符将按原样输出，一个转换说明有4个可选择的部分，如下面方框中所示：  </p>
<blockquote>
<p>[flags][fldwidth][precision][lenmodifier]convtype</p>
</blockquote>
<blockquote>
<p>【标志】【宽度】【精度】【长度】转化类型</p>
</blockquote>
<p>flag参数取值如下：<br> <img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.2.PNG" alt="图片"> </p>
<p>&emsp;&emsp;fldwidth参数说明了最小字段宽度，转换后参数字符数若小于宽度，则用空格填充，字段宽度是一个非负十进制数，或者是一个（<em>）号。<br>&emsp;&emsp;precision参数说明整形转换后最少输出数字位数，浮点数转化后小数点后的最少位数，字符串转换后最大字节数。精度是一个（.），其后跟随一个非负十进制数或一个（</em>）。<br>&emsp;&emsp;lenmodified参数说明参数长度，取值如下：  </p>
<p> <img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.3.PNG" alt="图片"> </p>
<p>&emsp;&emsp;convtype参数不是可选的，它控制如何解释参数，取值如下：</p>
<p> <img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.4.PNG" alt="图片"> </p>
<p>&emsp;&emsp;②格式化输入由3个scanf函数处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int scanf(const char *restrict format, …);</span><br><span class="line">int fscanf(FILE *restrict fp, const char *restrict format, …);</span><br><span class="line">int sscanf(const char *restrict buf, const char *restrict format, …);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;scanf族用于分析输入字符串，并将字符序列转换成指定类型的变量，在格式之后的各参数包含了变量的地址，用转换结果对这些变量赋值。<br>&emsp;&emsp;format参数中，转换说明以%字符开始，有3个可选择的部分，如下所示：</p>
<blockquote>
<p>[*][fldwidth][m][lenmodifier]convtype</p>
</blockquote>
<p>*参数用于抑制转化，按照说明的其余部分对输入进行转换，但转换结果并不存放在参数中（也就是跳过此数据）。<br>fldwidth参数说明最大宽度（即最大字符数）。<br>lenmodified参数说明要用转换结果赋值的参数大小，如同printf函数族中一样。<br>convtype参数不是可选的，类似于printf函数族的转换类型字段，但两者有差别，一个差别是作为一种选项，输入中带符号的可以赋予无符号类型，例如，输入流中的-1被转换成4294967295。支持的转换类型如下：  </p>
<p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.5.PNG" alt="图片"> </p>
<p>m参数是赋值分配符，它可以%c、%s以及%[转化符，迫使内存缓冲区分配空间以接纳转换字符串，在这种情况下，相关的参数必须是指针地址，分配的缓冲区地址必须复制给该指针，如果调用成功，该缓冲区不在使用时，由调用者负责通过调用free函数来释放该缓冲区。</p>
<h1 id="十、实现细节"><a href="#十、实现细节" class="headerlink" title="十、实现细节"></a>十、实现细节</h1><p>&emsp;&emsp;在Unix中，标准I/O库最终都要调用内核I/O接口函数，每个标准I/O流都有一个与其相关联的文件描述符，可以对一个流调用fileno函数以获得其描述符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int fileno(FILE * fp);</span><br></pre></td></tr></table></figure>
<p>如果需要调用dup或fcntl等函数，则需要此函数转化。</p>
<h1 id="十一、临时文件"><a href="#十一、临时文件" class="headerlink" title="十一、临时文件"></a>十一、临时文件</h1><p>&emsp;&emsp;ISO C标准I/O库提供了两个函数以帮助创建临时文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">char *tmpnam(char *ptr);</span><br><span class="line">FILE *tmpfile(void);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;tmpnam函数产生一个与现有文件名不同的一个有效文件名字符串，每次调用它时，都产生一个不同的文件名，一般在/tmp下，最多调用次数是TMP_MAX。<br>tmpfile创建一个临时二进制文件（类型wb+），在关闭该文件或程序结束时将自动删除这种文件，注意，Unix对二进制文件不进行特殊区分。<br>程序示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">        char name[L_tmpnam], line[MAXLINE];</span><br><span class="line">        FILE *fp;</span><br><span class="line">        printf(&quot;%s\n&quot;, tmpnam(NULL));</span><br><span class="line">        tmpnam(name);</span><br><span class="line">        printf(&quot;%s\n&quot;, name);</span><br><span class="line">        if((fp &#x3D; tmpfile()) &#x3D;&#x3D; NULL)</span><br><span class="line">                err_sys(&quot;tmpfile error&quot;);</span><br><span class="line">        fputs(&quot;one line of output\n&quot;, fp);</span><br><span class="line">        rewind(fp);</span><br><span class="line">        if(fgets(line, sizeof(line), fp) &#x3D;&#x3D; NULL)</span><br><span class="line">                err_sys(&quot;fgets error&quot;);</span><br><span class="line">        fputs(line, stdout);</span><br><span class="line">        exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行：./a.out<br>/tmp/fileUMleJc<br>/tmp/fileSX9RnR<br>one line of output  </p>
</blockquote>
<p>&emsp;&emsp;tmpfile函数经常使用的标准Unix技术是先调用tmpnam函数产生一个唯一的路径名，然后，用该路径名创建一个文件，并立即unlink它，对一个文件解除链接并不删除其内容，关闭文件时才删除其内容，而关闭文件可以是显式的，也可以在程序终止时自动进行。</p>
<h1 id="十二、内存流"><a href="#十二、内存流" class="headerlink" title="十二、内存流"></a>十二、内存流</h1><p>&emsp;&emsp;可以看到，标准I/O库把数据缓存在内存中，因此每次一个字符和一行字符的I/O更有效，内存流就是标准I/O流，虽然使用FILE指针进行访问，但其实没有底层文件，所有的I/O都是通过在缓冲区与主存来回传送字节来完成的，即便这些流看起来更像文件流，其实它们的某些特征更适用于字符串操作。有3个函数用于创建内存流：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">FILE *fmemopen(void *restrict buf, size_t size, const char *restrict type);</span><br></pre></td></tr></table></figure>
<p>fmemopen函数允许调用者提供缓冲区用于内存流，buf参数指向缓冲区的开始位置，size参数指定了缓冲区字节的大小，若果buf为空，fmemopen函数分配size字节数的缓冲区，在这种情况下，当流关闭时缓冲区会被释放。<br>type参数控制如何使用流：</p>
<p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/5.6.PNG" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">FILE *open_memstream(char **bufp, size_t *sizep);</span><br><span class="line">#include &lt;wchar.h&gt;</span><br><span class="line">FILE *open_wmemstream(wchar_t **bufp, size_t *sizep);</span><br></pre></td></tr></table></figure>
<p>open_memstream函数创建的流是面向字节的，open_wmemstream函数创建的流是面向宽字节的。</p>
<h1 id="十三、-小结"><a href="#十三、-小结" class="headerlink" title="十三、    小结"></a>十三、    小结</h1><p>&emsp;&emsp;大多数Unix应用程序都是用标准I/O库，它使用缓冲技术，而他正是产生许多问题，引起许多混淆的地方。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/09/05/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/" rel="prev" title="linux学习笔记(3)—文件与目录">
                  <i class="fa fa-chevron-left"></i> linux学习笔记(3)—文件与目录
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/02/21/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BB%88%E7%AB%AF/" rel="next" title="linux学习笔记(5)-终端">
                  linux学习笔记(5)-终端 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">严薇南</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  





</body>
</html>
