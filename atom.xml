<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小威的博客</title>
  
  <subtitle>天下代码，一把Copy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-31T14:40:04.801Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小威</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unix笔记1—基础知识</title>
    <link href="http://yoursite.com/2018/08/30/Linux1/"/>
    <id>http://yoursite.com/2018/08/30/Linux1/</id>
    <published>2018-08-30T12:15:34.000Z</published>
    <updated>2018-08-31T14:40:04.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>&emsp;&emsp;操作系统为所运行的程序提供服务，典型服务有：</p><blockquote><p>①执行新程序<br>②打开文件<br>③读取文件<br>④分配存储区<br>⑤获取系统时间  </p></blockquote><h1 id="二、Unix体系结构"><a href="#二、Unix体系结构" class="headerlink" title="二、Unix体系结构"></a>二、Unix体系结构</h1><p>&emsp;&emsp;操作系统是一种软件，它控制计算机系统资源，提供程序运行环境，通常称其为 <strong>内核（kernel）</strong> ,因为它相对较小，而且处于环境的核心。内核接口称为 <strong>系统调用，公用函数库</strong> 建立于系统调用之上，应用程序可以使用 <strong>系统调用</strong> 和 <strong>公用函数库</strong> , <strong>Shell</strong> 是一个特殊的应用程序，为运行其它应用程序提供一个接口。</p><h1 id="三、登录"><a href="#三、登录" class="headerlink" title="三、登录"></a>三、登录</h1><p>&emsp;&emsp;登录Unix时，必须键入 <strong>用户名</strong> 和 <strong>密码</strong> ，存在于 <strong>/etc/passwd</strong> 文件。</p><h1 id="四、shell"><a href="#四、shell" class="headerlink" title="四、shell"></a>四、shell</h1><p>&emsp;&emsp;shell是一个 <strong>命令行解释器</strong> ，它读取用户输入，然后执行命令，输入来自终端或者文件（shell脚本）。</p><h1 id="五、文件和目录"><a href="#五、文件和目录" class="headerlink" title="五、文件和目录"></a>五、文件和目录</h1><p>&emsp;&emsp;① <strong>文件系统</strong> 是目录和文件的一种层次结构，起点是根目录（root），符号为”\”。<br>&emsp;&emsp;② <strong>目录</strong> 是一个包含目录项的文件，目录项=文件名+文件属性，文件属性包含文件类型（普通文件/目录）、文件大小、文件所有者、文件权限及文件最后修改的时间。<br>&emsp;&emsp;③ <strong>文件名</strong> 是目录项中的各个名字，”/“和” “不能出现在文件名中，创建新目录是会自动创建两个文件名，分别是”.” <strong>当前目录</strong> 和”..” <strong>上一目录</strong> ，处于根目录时，”.”=”..”。<br>&emsp;&emsp;④ <strong>路径名</strong> 是由斜线分割的一个或多个文件名组成的序列，分别 <strong>绝对路径</strong> 和 <strong>相对路径</strong> 。<br>&emsp;&emsp;⑤ <strong>列出目录</strong> 中所有文件名的代码如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &quot;dirent.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) </span><br><span class="line">&#123;</span><br><span class="line">  DIR *dp;</span><br><span class="line">  struct dirent *dirp;</span><br><span class="line">  if(argc != 2)</span><br><span class="line">    err_quit(&quot;usage: ls directory_name&quot;);</span><br><span class="line">  if((dp = opendir(argv[1])) == NULL)</span><br><span class="line">    err_sys(&quot;can&apos;t open %s&quot;, argv[1]);</span><br><span class="line">  while((dirp = readdir(dp)) != NULL)</span><br><span class="line">    printf(&quot;%s\n&quot;,dirp-&gt;d_name);</span><br><span class="line">  closedir(dp);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释</strong> ：<br>行1：apue.h为作者自定义头文件，需先下载至系统。<br>行2：系统头文件，/user/include/dirent.h，可以使用 <strong>dirent</strong> 结构和 <strong>opendir</strong> 、 <strong>readdir</strong> 函数。<br>行4：ISO C风格的main函数声明， <strong>argc参数</strong> 是传入命令行的字符串数目， <strong>*argv[]</strong> 是具体的命令行字符。<br>行6：opendir将返回DIR结构指针。<br>行7：readdir将返回dirent结构指针。<br>行8、9：传入命令行字符串数目错误，输出提示信息。<br>行10、11：传入路径为空时，输出提示信息。<br>行12、13：读取每个目录项并打印。<br>行14：释放目录<br>行15：exit终止程序，参数0表示正常结束，1-255表示出错。  </p></blockquote><blockquote><p><strong>执行</strong> ：<br>使用 <strong>cc *.c</strong> 进行编译（cc=gcc），默认生成 <strong>a.out</strong> 文件，运行命令行 <strong>./a.out /dir</strong> ，即可列出dir目录下所有文件名，dir为所需目录名。</p></blockquote><h1 id="六、输入和输出"><a href="#六、输入和输出" class="headerlink" title="六、输入和输出"></a>六、输入和输出</h1><p>&emsp;&emsp;① <strong>文件描述符</strong> 是一个小的非负整数，内核用来标定一个特定进程正在访问的文件。当内核打开一个文件或创建一个文件时，它都返回一个文件描述符，在读/写文件时使用这个文件描述符。<br>&emsp;&emsp;② <strong>标准输入、标准输出、标准错误</strong><br>当运行一个新程序时，shell将打开以上三个文件描述符，一般这三个文件描述符都指向终端，shell可以将这些文件描述符重新定向到某个文件，如：ls&gt;file.list。<br>&emsp;&emsp;③ <strong>不带缓冲的I/O</strong><br>函数open、read、lseek、close提供了不带缓冲的I/O，这些函数都使用文件描述符。<br>&emsp;&emsp;④ <strong>复制任一Unix普通文件</strong> 代码如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#define BUFFSIZE 4096</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   int n;</span><br><span class="line">   char buf[BUFFSIZE];</span><br><span class="line">   while((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0)</span><br><span class="line">      if(write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">         err_sys(&quot;write error!&quot;);</span><br><span class="line">   if(n&lt;0)</span><br><span class="line">      err_sys(&quot;read error!&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释：</strong><br>行7、8、9：常量STDIN_FILENO和STDOUT_FILENO是POSIX标准的一部分，定义在&lt;unistd.h&gt;中，它们指定了标准输入和输出的文件描述符，值分别为0和1，read函数返回读取的字节数，读到文件尾端时将返回0，如果读错误将返回-1。  </p></blockquote><blockquote><p><strong>执行：</strong><br>./a.out &gt; data ：输入是终端（ctrl+D结束），输出是data文件。<br>./a.out <infile>outfile：输入是infile文件，输出是outfile文件。  </infile></p></blockquote><p>&emsp;&emsp;⑤ <strong>标准I/O</strong><br>标准I/O函数为那些不带缓冲的I/O函数提供了一个 <strong>带缓冲的接口</strong> ，使用标准I/O函数无需担心选取最佳缓冲区大小，标准I/O函数还简化了输入行的处理，例如：fgets函数读取一个完整的行，read函数读取指定字节数，printf是我们最熟悉的标准I/O函数之一，&lt;stdio.h&gt;包含了所有标准I/O函数的原型。<br>&emsp;&emsp;⑥ <strong>将标准输入复制到标准输出</strong> 代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   int c;</span><br><span class="line">   while((c = getc(stdin)) != EOF)</span><br><span class="line">      if(putc(c, stdout) == EOF)</span><br><span class="line">         err_sys(&quot;output error!&quot;);</span><br><span class="line">      if(ferror(stdin))</span><br><span class="line">         err_sys(&quot;input error!&quot;);</span><br><span class="line">      exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释：</strong><br>行5、6：函数getc一次读取一个字符，putc显示在屏幕上，常量EOF（end of file）定义在&lt;stdio.h&gt;中，表示文件结束标志（Ctrl+D），值为-1，stdin和stdout也定义在&lt;stdio.h&gt;，分别表示标准输入和标准输出。  </p></blockquote><blockquote><p><strong>执行：</strong><br>./a.out  </p></blockquote><h1 id="七、程序和进程"><a href="#七、程序和进程" class="headerlink" title="七、程序和进程"></a>七、程序和进程</h1><p>&emsp;&emsp;① <strong>程序</strong> 是存储在磁盘中的可执行文件，内核使用 <strong>exec</strong> 函数，将程序 <strong>读入内存</strong> ， <strong>并执行程序</strong> 。<br>&emsp;&emsp;② <strong>进程和进程ID</strong><br>程序的执行实例被称为 <strong>进程（process）</strong> ，某些操作系统用 <strong>任务（task）</strong> 表示正在被执行的程序，Unix系统确保每个进程都有一个唯一的数字标识符，成称为进程ID，它总是一个非负的整数。<br>&emsp;&emsp;③ <strong>打印进程ID号代码如下：</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;hello world form process ID %ld\n&quot;,(long)getpid());</span><br><span class="line">   exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释：</strong><br>getpid函数用于返回进程ID值，类型为pid_t类型。  </p></blockquote><blockquote><p><strong>执行：</strong><br>./a.out  </p></blockquote><p>&emsp;&emsp;④ <strong>进程控制。</strong><br>有3个用于进程控制的主要函数， <strong>fork、exec、waitpid（exec有7种变体）</strong><br>&emsp;&emsp;⑤ <strong>从标准输入读取命令并执行</strong> 代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &quot;sys/wait.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   char buf[MAXLINE];</span><br><span class="line">   pid_t pid;</span><br><span class="line">   int status;</span><br><span class="line">   printf(&quot;%% &quot;);</span><br><span class="line">   while(fgets(buf, MAXLINE, stdin) != NULL)</span><br><span class="line">   &#123;</span><br><span class="line">      if(buf[strlen(buf) - 1] == &apos;\n&apos;)</span><br><span class="line">      &#123;</span><br><span class="line">        buf[strlen(buf) - 1] = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if((pid = fork()) &lt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">         err_sys(&quot;fork error!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else if(pid == 0)</span><br><span class="line">      &#123;</span><br><span class="line">         execlp(buf, buf, (char*)0);</span><br><span class="line">         err_ret(&quot;couldn&apos;t execute: %s&quot;, buf);</span><br><span class="line">         exit(127);</span><br><span class="line">      &#125;</span><br><span class="line">      if((pid = waitpid(pid, &amp;status, 0)) &lt; 0)</span><br><span class="line">        err_sys(&quot;waitpid error&quot;);</span><br><span class="line">      printf(&quot;%% &quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   exit(0);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释：</strong><br>行12、13、14、15：因为fgets每一行都以换行符终止，而execlp函数要以null结尾，因此要替换一下。<br>行16：调用fork创建一个新进程，新进程是调用进程的一个副本，新进程称为 <strong>子进程</strong> ，调用进程称为 <strong>父进程</strong> ，fork对父进程返回子进程的ID，对子进程则返回0，fork调用一次，返回两次。<br>行22：子进程调用execlp（从PATH 环境变量中查找文件并执行， <strong>执行成功函数将不会返回，失败返回-1</strong> ）执行从标准输入的命令，用新的程序文件替换子进程原先执行的程序文件。<br>行27：父进程通过调用waitpid等待子进程执行完毕，其参数1指定要等待的进程，waitpid返回子进程的终止状态（status变量）。  </p></blockquote><p>&emsp;&emsp;⑥ <strong>线程和线程ID</strong><br>一个进程内的所有线程共享同一个地址空间、文件描述符、栈及其进程相关的属性，所以各线程需要采集同步措施，以避免不一致性，线程也有ID，但只在本身进程内起作用。  </p><h1 id="八、出错处理"><a href="#八、出错处理" class="headerlink" title="八、出错处理"></a>八、出错处理</h1><p>&emsp;&emsp;当Unix系统函数出错时，一般返回一个负值，而 <strong>整形变量errno</strong> 被设置为具有特定信息的值，文件&lt;errno.h&gt;定义了errno以及它可以被赋的值，POSIX和ISO C将errno定义为一个符号，它扩展为一个可修改的 <strong>整形左值</strong> ，它可以是一个包含出错编号的 <strong>整数</strong> ，也可以是一个返回出错编号指针的函数，使用应该注意两项：1、如果没有出错，其值不会被清除，因此当函数返回值表明错误时，才需要去检验其值。2、任何函数都不会将errno的值置0。<br>&emsp;&emsp;C标准定义了两个函数，用于打印出错信息。<br> <strong>#include &lt;string.h&gt;</strong><br> <strong>char *strerror(int errnum);</strong>   //返回错误字符串指针，通常errnum就是errno<br> <strong>#include &lt;stdio.h&gt;</strong><br> <strong>void perror(const char *msg);</strong>   //首先输出msg指向的字符串，然后添加冒号和空格，接着输出errno值的出错消息，最后换行。<br>实例代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">   fprintf(stderr, &quot;EACCES: %s\n&quot;,strerror(EACCES));</span><br><span class="line">   errno = ENOENT;</span><br><span class="line">   perror(argv[0]);</span><br><span class="line">   exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、用户标识"><a href="#九、用户标识" class="headerlink" title="九、用户标识"></a>九、用户标识</h1><p>&emsp;&emsp;① <strong>用户ID</strong> 是一个数值，用户ID为0的用户是 <strong>根用户</strong> 和 <strong>超级用户</strong> 。<br>&emsp;&emsp;② <strong>组ID</strong> 是一个数值，组用户用于将若干用户集合到项目或部门中去，这种机制允许同组的各个成员之间共享资源，组文件通常是/etc/group。<br>&emsp;&emsp;③ <strong>getuid</strong> 和 <strong>getgid</strong> 用于获取用户ID和组ID。<br>&emsp;&emsp;④ <strong>附属组ID</strong>。</p><h1 id="十、信号"><a href="#十、信号" class="headerlink" title="十、信号"></a>十、信号</h1><p>&emsp;&emsp;信号用于通知进程发生了某种情况，进程有以下三种方式处理：</p><blockquote><p>忽略信号<br>按系统默认方式处理<br>提供一个函数  </p></blockquote><p>很多情况都会产生信号，终端键盘有两种产生信号的办法，分别称为 <strong>中断键（Delete或Ctrl+C）</strong> 和 <strong>退出键（Ctrl+\）</strong> ，他们被用于终止当前运行的进程，另一种产生信号的办法是调用 <strong>kill函数</strong> ，在一个进程中调用此函数可向另一个进程发送信号，信号函数是 <strong>signal</strong> 。</p><h1 id="十一、时间值"><a href="#十一、时间值" class="headerlink" title="十一、时间值"></a>十一、时间值</h1><p>&emsp;&emsp; <strong>Unix使用过两种不同的时间值：</strong>  </p><blockquote><p><strong>日历时间：</strong> 该值来自UTC，1970-01-01 00:00:00，这个时间所经过的秒数值，系统基本数据类型 <strong>time_t</strong> 用于保存这种时间。<br><strong>进程时间：</strong> 也称为CPU时间，用以度量进程使用的中央处理器资源，以时钟滴答计算，系统基本数据类型 <strong>clock_t</strong> 保存这种时间，使用sysconf可以得到每秒时钟滴答数。  </p></blockquote><p>&emsp;&emsp;Unix系统为一个进程维护了三个进程时间值：  </p><blockquote><p><strong>时钟时间</strong>—进程运行的时间总量。<br><strong>用户CPU时间</strong>—执行用户指令所需时间。<br><strong>系统CPU时间</strong>—该进程执行内核程序所经历的时间。  </p></blockquote><h1 id="十一、小结"><a href="#十一、小结" class="headerlink" title="十一、小结"></a>十一、小结</h1><p>&emsp;&emsp;本文快速浏览了unix系统的全局，对Unix系统有了一个基本印象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;操作系统为所运行的程序提供服务，典型服务有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;①执行新程序&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Unix笔记2—文件I/O</title>
    <link href="http://yoursite.com/2018/08/30/Linux2/"/>
    <id>http://yoursite.com/2018/08/30/Linux2/</id>
    <published>2018-08-30T12:15:34.000Z</published>
    <updated>2018-09-01T10:57:58.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>&emsp;&emsp;①可用的 <strong>文件I/O函数</strong> ：打开文件、读文件、写文件。<br>&emsp;&emsp;②常用5个函数： <strong>open、read、write、lseek、close</strong> （不同缓冲长度影响将不同）。<br>&emsp;&emsp;③ <strong>不带缓冲I/O</strong> 是指每个read、write都调用内核中的一个系统函数，需要传入缓存区参数。<br>&emsp;&emsp;④ <strong>原子操作</strong> 及 <strong>dup、fcntl、sync、fsync、ioctl</strong> 函数。 </p><h1 id="二、文件描述符"><a href="#二、文件描述符" class="headerlink" title="二、文件描述符 "></a>二、文件描述符 </h1><p>&emsp;&emsp;①当打开一个现有文件或创建一个新文件时，内核向进程返回一个 <strong>文件描述符</strong> ，文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的 <strong>索引</strong> ，其值是一个非负整数，用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符，程序刚刚启动的时候：</p><blockquote><p><strong>0是标准输入（STDIN_FILENO）<br>1是标准输出（STDOUT_FILENO）<br>2是标准错误（STDERR_FILENO）</strong><br>如果此时去打开一个新的文件，它的文件描述符会是3。  </p></blockquote><p>&emsp;&emsp;②文件描述符变化范围： <strong>0~OPEN_MAX-1</strong> 。</p><h1 id="三、函数open和openat"><a href="#三、函数open和openat" class="headerlink" title="三、函数open和openat"></a>三、函数open和openat</h1><p>&emsp;&emsp;①open、openat打开/创建文件，成功则返回文件描述符，失败返回-1。<br>&emsp;&emsp;②open、opena函数原型。<br>&emsp;&emsp; <strong>#include&lt;fcntl.h&gt;</strong><br>&emsp;&emsp; <strong>int open(const char *path, int oflags, …, mode_t mode);</strong><br>&emsp;&emsp; <strong>int openat(int fd, const char *path, int oflags, …, mode_t mode);</strong><br>&emsp;&emsp;path-路径名（绝对路径）或者文件名（相对路径）。<br>&emsp;&emsp;oflags-打开文件采取的动作</p><blockquote><p>以下是必选参数（只能一个）：<br>O_RDONLY(只读)<br>O_WRONLY（只写）<br>O_RDWR（可读可写）  </p></blockquote><blockquote><p>以下是可选参数：<br>O_APPEND(每次写操作都写入文件的末尾)<br>O_CREAT(如果指定文件不存在，则创建这个文件)<br>O_EXCL(如果要创建的文件已存在，则返回-1，并且修改errno的值)<br>O_TRUNC(如果文件存在，并且以只写/读写方式打开，则清空文件全部内容)<br>O_NOCTTY(如果路径名指向终端设备，不要把这个设备用作控制终端)<br>O_NONBLOCK(如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继I/O设置为非阻塞模式(nonblocking mode))  </p></blockquote><p>&emsp;&emsp;fd-区别open、openat，有3种可能性:  </p><blockquote><p>path是绝对路径名，此时fd无用，open=openat。<br>path是相对路径名，fd指定相对路径起始。<br>path是相对路径名，fd=AT_FDCWD，相对路径起始=当前工作目录。  </p></blockquote><p>&emsp;&emsp;③open、openat函数返回的文件描述符一定是最小未用的。<br>&emsp;&emsp;④openat可以让线程使用相对路径名打开目录中的文件，而不受限于当前目录。  </p><h1 id="四、函数creat"><a href="#四、函数creat" class="headerlink" title="四、函数creat"></a>四、函数creat</h1><p>&emsp;&emsp;①creat函数用于创建新文件，成功则返回文件描述符，失败返回-1。<br>&emsp;&emsp;②creat函数原型。<br>&emsp;&emsp; <strong>int creat (const char *path, mode_t mode);</strong><br>&emsp;&emsp;③类似于open。  </p><h1 id="五、函数close"><a href="#五、函数close" class="headerlink" title="五、函数close"></a>五、函数close</h1><p>&emsp;&emsp;①close函数用于关闭文件，成功则返回文件描述符，失败返回-1。<br>&emsp;&emsp;②close函数原型。<br>&emsp;&emsp; <strong>int close(int fd);</strong><br>&emsp;&emsp;③当一个进程终止时，内核自动关闭它打开的所有文件。  </p><h1 id="六、函数lseek"><a href="#六、函数lseek" class="headerlink" title="六、函数lseek"></a>六、函数lseek</h1><p>&emsp;&emsp;①lseek用于使光标偏移，成功则返回新的偏移量（初始默认为0），失败返回-1。<br>&emsp;&emsp;②lseek函数原型。<br>&emsp;&emsp; <strong>off_t lseek(int fd, off_t offset, int whence);</strong>  </p><blockquote><p>whence=SEEK_SET，该文件偏移至文件开始处offset个字节。<br>whence=SEEK_CUR，该文件偏移至当前偏移量加offset。<br>whence=SEEK_END，该文件偏移至当文件长度加offset。  </p></blockquote><p>&emsp;&emsp;③检测当前偏移量 <strong>off_t currpos = lseek(fd, 0, SEEK_CUR);</strong><br>&emsp;&emsp;④检测标准输入能否设置偏移量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    if(lseek(STDIN_FILENO, 0, SEEK_CUR) == -1)</span><br><span class="line">        printf(&quot;cannot seek!&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;seek OK!&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;应该测试返回值是否为-1，而不是&lt;0，因为某些设备允许负的偏移量，文件偏移量可以大于文件的当前长度。</p><h1 id="七、函数read"><a href="#七、函数read" class="headerlink" title="七、函数read"></a>七、函数read</h1><p>&emsp;&emsp;①read函数用于打开文件读数据,成功返回字节数，到达文件尾返回0，失败返回-1。<br>&emsp;&emsp;②read函数原型。<br>&emsp;&emsp; <strong>ssize_t read(int fd, void *buf, size_t nbytes);</strong> </p><h1 id="八、函数write"><a href="#八、函数write" class="headerlink" title="八、函数write"></a>八、函数write</h1><p>&emsp;&emsp;①write函数用于打开文件写数据，成功返回写入字节数，失败返回-1。<br>&emsp;&emsp;②write函数原型。<br>&emsp;&emsp; <strong>ssize_t write(int fd, const void *buf, size_t nbytes);</strong><br>&emsp;&emsp;③write返回值通常等于nbytes，它的一个出错原因是磁盘被写满，或者超过了给定一个进程的文件长度限制。<br>&emsp;&emsp;④对于普通文件，写操作从当前偏移量开始，如果打开文件指定了O_APPEND选项，则每次写操作前，将文件偏移量设置到文件尾端，一次写成功后，该文件偏移量增加实际写的字节数。  </p><h1 id="九、I-O的效率"><a href="#九、I-O的效率" class="headerlink" title="九、I/O的效率"></a>九、I/O的效率</h1><p>&emsp;&emsp;①只使用write和read函数将标准输入复制到标准输出。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#define BUFFSIZE 4096</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    char buf[BUFFSIZE];</span><br><span class="line">    while((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0)</span><br><span class="line">        if(write(STDIN_FILENO, buf, n) != n)</span><br><span class="line">            err_sys(&quot;write error!&quot;);</span><br><span class="line">    if(n&lt;0)</span><br><span class="line">        err_sys(&quot;read error!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;②磁盘块长度由 <strong>st_blksize</strong> 表示，缓冲区 <strong>BUFFSIZE</strong> 使用4096（等于st_blksize）时，进程使用系统CPU时间最短。</p><h1 id="十、文件共享"><a href="#十、文件共享" class="headerlink" title="十、文件共享"></a>十、文件共享</h1><p>&emsp;&emsp;①Unix系统支持不同进程间共享打开文件 <strong>（多个进程同时读）</strong>。<br>&emsp;&emsp;②内核使用三种数据结构表示打开文件，分别是 <strong>文件描述符表</strong>、 <strong>文件表</strong>和 <strong>V节点表</strong>。<br>&emsp;&emsp;每个 <strong>进程</strong> 在 <strong>进程表</strong>中都有一个 <strong>记录项</strong>，记录项中包含一张 <strong>打开文件描述符表</strong> ，每个描述符占用一项。与每个文件描述符相关联的是：</p><blockquote><p>(a)    文件描述符标志。<br>(b)    指向一个文件表项的指针。  </p></blockquote><p>&emsp;&emsp;内核为所有打开文件维持一张 <strong>文件表</strong> ，每个文件表项包含:  </p><blockquote><p>(a)    文件状态标志(读、写、添写、同步和非阻塞等)。<br>(b)    当前文件偏移量。<br>(c)    指向该文件 V 节点表项的指针。  </p></blockquote><p>&emsp;&emsp;每个打开文件都有一个v节点结构(v-node)，v节点包含了 <strong>文件类型</strong> 和对此文件进行各种操作的 <strong>函数指针</strong> 。v节点还包含了从磁盘读取的 <strong>i节点(i-node)</strong> 的信息，i节点信息包含了 <strong>文件的所有者、文件长度、文件所在的设备、指向文件的实际数据块在磁盘上所在位置的指针</strong> 等。<br>&emsp;&emsp;图1表示了三张表之间的关系，该进程有两个不同的打开文件，分别是标准输入和标准输出。</p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/3.1.PNG" alt="图片"></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; <strong>图1:一个进程打开两个文件的内核数据结构</strong></p><p>&emsp;&emsp;图2表示两个进程打开同一个文件的内核数据结构，假定第一个进程在文件描述符3上打开该文件，而另一个进程在文件描述符4上打开该文件，则打开该文件的 <strong>每个进程都得到一个文件表项</strong> ，但对一个给定的文件 <strong>只有一个v节点表项</strong>。</p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/3.2.PNG" alt="图片"></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; <strong>图2:两个进程打开一个文件的内核数据结构</strong>  </p><p>&emsp;&emsp;③对前面所述操作的进一步说明。</p><blockquote><p>(a)每个进程都有自己的对打开文件的 <strong>当前偏移量</strong>。<br>(b)在完成每个write后,在文件表项中的当前文件偏移量即增加所写的字节数。如果这使当前文件偏移量超过了当前文件长度，则在i节点表项中的当前文件长度被设置为当前文件偏移量。<br>(c)若一个文件用lseek定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为i节点表项中的当前文件长度。 <strong>（这与O_APPEND标志打开文件是不同的，使用lseek定位到文件尾端处后，下次调用write写数据不一定是写在该文件的真正尾端，因为lseek和write两个不是原子操作，中间可以有另一个进程已使文件长度变长了。）</strong><br>(d)如果用O_APPEND 标志打开了一个文件，则相应标志被设置到文件表项的文件状态标志中， <strong>每次对这种具有添写标志的文件执行写操作时，在文件表项中的当前文件偏移量首先被设置成i节点表项中的文件长度，这就使得每次写的数据都添加到文件的当前尾端处。</strong><br>(e)lseek 函数只修改文件表项中的当前文件偏移量，没有进行任何I/O操作。  </p></blockquote><p>&emsp;&emsp;④以上过程可使得多个进程同时 <strong>读取</strong> 同一个文件，每个进程都有它自己的文件表项和当前偏移量。  </p><h1 id="十一、原子操作"><a href="#十一、原子操作" class="headerlink" title="十一、原子操作"></a>十一、原子操作</h1><p>&emsp;&emsp;①任何多于一个函数调用的操作都不是原子操作，因为两个函数调用之间，内核有可能会临时挂起进程。<br>&emsp;&emsp;②Unix系统提供了一种原子操作方法，即在打开文件时设定 <strong>O_APPEND标志</strong> ，这样做使得每次写操作之前，都将进程的当前偏移量设置为文件尾端，于是每次写操作的时候就不用lseek函数了。<br>&emsp;&emsp;③函数pread和pwrite。<br>&emsp;&emsp;     调用pread相当于先调用lseek后再调用read，但调用pread时，此过程无法被打断，并且不更新当前文件偏移量。<br>&emsp;&emsp;     调用pwrite相当于先调用lseek后再调用write。<br>&emsp;&emsp;④ <strong>一般而言，原子操作是指由多步组成的一个操作，如果该操作原子的执行，则要么执行完所有步骤，要么一步也不执行，原子操作也就是能被打断的最小操作。</strong></p><h1 id="十二、函数dup和dup2"><a href="#十二、函数dup和dup2" class="headerlink" title="十二、函数dup和dup2"></a>十二、函数dup和dup2</h1><p>&emsp;&emsp;①两个函数均用来复制一个现有的文件描述符，成功返回新的文件描述符，失败返回-1。<br>&emsp;&emsp;②函数原型。<br>&emsp;&emsp; <strong>#include &lt;unistd.h&gt;</strong><br>&emsp;&emsp; <strong>int dup(int fd);</strong><br>&emsp;&emsp; <strong>int dup2(int fd, int fd2);</strong><br>&emsp;&emsp;③dup函数返回的一定是当前可用数值最小的文件描述符，dup2函数可以指定新的文件描述符。  </p><h1 id="十三、函数sync、fsync和fdatasync"><a href="#十三、函数sync、fsync和fdatasync" class="headerlink" title="十三、函数sync、fsync和fdatasync"></a>十三、函数sync、fsync和fdatasync</h1><p>&emsp;&emsp;①Unix系统实现设有高速缓冲区，大多数磁盘I/O都通过缓冲区进行，当我们向文件写入数据时，内核通常先将数据复制到缓冲区，然后排入队列，晚些时候再存入磁盘，这种方式成为延迟写，如果内核要重用缓冲区，它会把所有延迟写数据块写入磁盘。<br>&emsp;&emsp;②为了保证磁盘与缓冲区数据一致，Unix系统提供了sync、fsync和fdatasync函数。  </p><blockquote><p>sync函数：只是将修改后的数据排入写队列，然后返回，不等待写入磁盘。<br>fsync函数：只对文件描述符fd指定的文件起作用，并等待写入磁盘。<br>fdatasync函数：类似于fsync，但它只影响文件的数据部分和同步更新文件的属性。  </p></blockquote><h1 id="十四、函数fcntl"><a href="#十四、函数fcntl" class="headerlink" title="十四、函数fcntl"></a>十四、函数fcntl</h1><p>&emsp;&emsp;①用于改变已经打开文件的属性，成功返回由cmd决定，失败返回-1。<br>&emsp;&emsp;②函数原型。<br>&emsp;&emsp; <strong>#include &lt;fcntl.h&gt;</strong><br>&emsp;&emsp; <strong>int fcntl(int fd, int cmd, …/<em> int arg </em>/);</strong><br>&emsp;&emsp;cmd有11种取值，这里未列出。 </p><h1 id="十五、函数ioctl"><a href="#十五、函数ioctl" class="headerlink" title="十五、函数ioctl"></a>十五、函数ioctl</h1><p>&emsp;&emsp;①ioctl是设备驱动程序中对设备的I/O通道进行管理的函数，即对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等，需要驱动程序提供对ioctl的支持。<br>&emsp;&emsp;②函数原型。<br>&emsp;&emsp; <strong>#include &lt;sys/ioctl.h&gt;</strong><br>&emsp;&emsp; <strong>int ioctl(int d,int request,….);</strong> </p><h1 id="十六、小结"><a href="#十六、小结" class="headerlink" title="十六、小结"></a>十六、小结</h1><p>&emsp;&emsp;本文学习了文件描述符的定义和基本作用，以及Unix系统提供的基本I/O函数。在多个进程读取文件时，了解了文件共享机制，为了防止多个进程同时写同一文件带来的干扰，学习了原子操作，最后还学习了fcntl和ioctl函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、引言&quot;&gt;&lt;a href=&quot;#一、引言&quot; class=&quot;headerlink&quot; title=&quot;一、引言&quot;&gt;&lt;/a&gt;一、引言&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;①可用的 &lt;strong&gt;文件I/O函数&lt;/strong&gt; ：打开文件、读文件、写文件。&lt;br&gt;&amp;e
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>433M无线模块组网应用</title>
    <link href="http://yoursite.com/2018/06/04/433M%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BD%91%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/06/04/433M无线模块组网应用/</id>
    <published>2018-06-04T04:56:40.000Z</published>
    <updated>2018-09-01T10:42:31.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、无线模块的发展背景"><a href="#一、无线模块的发展背景" class="headerlink" title="一、无线模块的发展背景"></a>一、无线模块的发展背景</h1><p>&emsp;&emsp;传统的有线连接不仅成本高，而且在特殊场合时，布线安装困难，维护也不方便，不能满足智能行业的发展需求，因此无线的应用便得到了发展，而且肯定是今后的发展趋势。<br>&emsp;&emsp;在无线传输时，采用433M频段有什么优点呢？</p><blockquote><p>   1、433M是免费频段<br>   2、433M传输距离远<br>   3、433M抗干扰能力强<br>   4、433M在传输速度和绕射性能两个方面要相对平衡</p></blockquote><h1 id="二、无线组网的一主多从传输机制"><a href="#二、无线组网的一主多从传输机制" class="headerlink" title="二、无线组网的一主多从传输机制"></a>二、无线组网的一主多从传输机制</h1><p>&emsp;&emsp;无线组网应用中，如果只采用点对点收发数据的话，在很多场合都是不能满足要求的，因此便有了一主多从轮询的方式，该组网方式有着 <strong>准确上传、设备之间不容易发生冲突、组网稳定</strong> 的优点，但是当从设备数目较多时，轮询时间开销比较大，对于主机来说，功耗也比较大，这种方式只适用于对 <strong>时间和功耗要求不高</strong> 的组网场合。   </p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/1.1.png" alt="图片"></p><p>&emsp;&emsp;一主多从轮询机制原理很简单，即通过点名的方式实现应答，这就要求每个从设备要有一个地址，而且这个地址必须是唯一的。如主机发送命令给地址编号为1的从机，只有1号从机能够响应主机，将数据上传给主机，主机再以相同的方式轮询其它从机数据。  </p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/1.2.png" alt="图片"></p><p>&emsp;&emsp;这种轮询机制原理相对简单，并且容易实现，但是效率很低，主机一直处于轮询状态，从机处于应答状态，主从机都一直处于工作状态，因此功耗无法降低，这种方式将不适用于太阳能供电或者电池供电的场合。</p><h1 id="三、低功耗无线组网"><a href="#三、低功耗无线组网" class="headerlink" title="三、低功耗无线组网"></a>三、低功耗无线组网</h1><p>&emsp;&emsp;低功耗无线组网采用分时间片的方式，具体实现如下：<br>&emsp;&emsp;首先，主机发起广播（所有从机均可收到），广播当前时间，所有从机时间同步后，主机再广播休眠时间，从机收到广播消息后，全部进入休眠模式，广播完成后，主机也进入休眠模式，当广播休眠定时时间到了后，主机和1号从机会被立刻唤醒，进入工作模式，从机上传数据，每个从机会根据地址进行延迟唤醒。例如：广播休眠时间t1=10s，数据传输时间t2=500ms，则1号机休眠时间为10s，上传数据时间为500ms，2号从机休眠时间为10.5s，上传数据时间为500ms，三号从机休眠时间为11s，上传数据时间为500ms，即</p><blockquote><p>从机休眠时间计算公式为：T = t1 + t2 * N<br>N：从机地址编号</p></blockquote><p>&emsp;&emsp;这种组网方式由于引入了休眠模式，避免了从机长时间处于应答状态，从而可以大大降低功耗，但是对主从机的时间精度要求较高。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>&emsp;&emsp;无线组网的方式有许许多多种，本文介绍了工程中常用的一主多从轮询机制，并且介绍了如何降低功耗及实现的基本原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、无线模块的发展背景&quot;&gt;&lt;a href=&quot;#一、无线模块的发展背景&quot; class=&quot;headerlink&quot; title=&quot;一、无线模块的发展背景&quot;&gt;&lt;/a&gt;一、无线模块的发展背景&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;传统的有线连接不仅成本高，而且在特殊场合时，
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工程应用" scheme="http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
</feed>
