<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Unix笔记3—文件与目录</title>
      <link href="/2018/09/05/Linux3/"/>
      <url>/2018/09/05/Linux3/</url>
      <content type="html"><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>&emsp;&emsp;本文将学习文件系统的其它性质和文件的性质，将从stat函数开始，逐个学习stat结构和的每一个成员以了解文件的所有属性，学习修改这些属性的各个函数（更改所有者，更改权限等）和Unix文件系统的结构以及符号链接。</p><h1 id="二、函数stat、fstat、fstatat和lstat"><a href="#二、函数stat、fstat、fstatat和lstat" class="headerlink" title="二、函数stat、fstat、fstatat和lstat"></a>二、函数stat、fstat、fstatat和lstat</h1><p>&emsp;&emsp;①函数原型  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">int stat(const char *restrict pathname, struct stat *restrict buf);  </span><br><span class="line">int fstat(int fd, struct stat *buf);  </span><br><span class="line">int lstat(const char *restrict pathname, struct stat *restrict buf;  </span><br><span class="line">int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所有4个函数的返回值：成功返回0，出错返回-1。<br>&emsp;&emsp; <strong>小知识：restrict是C99中一种类型限定符，作用是告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其它直接或间接的方式修改该对象的内容。</strong><br>&emsp;&emsp;②函数说明  </p><blockquote><pre><code>1、 **stat函数** 将返回与此命名文件有关的信息结构。  2、 **fstat函数** 获得已在描述符fd上打开文件的有关信息。  3、 **lstat函数** 类似于stat,但当命名文件是一个符号链接时，lstat返回该符号链接的有关信息，而不是由该符号链接引用的文件信息。  4、 **fstatat函数** 为一个相对于当前打开目录(由fd参数指向)的路径名返回文件统计信息。  5、 **buf是一个stat指针** ，它指向一个已经定义的结构，函数将buf指向的结构进行填充，stat结构如下： </code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct stat&#123;</span><br><span class="line">    mode_t              st_mode;  /* file type &amp; mode (permissions) */</span><br><span class="line">    ino_t               st_ino;   /* i-node number (serial number) */</span><br><span class="line">    dev_t               st_dev;   /* device number (file system) */</span><br><span class="line">    nlink_t             st_rdev;  /* device number for special files */</span><br><span class="line">    uid_t               st_uid;   /* user ID of owner */</span><br><span class="line">    gid_t               st_gid;   /* group ID of owner */</span><br><span class="line">    off_t               st_size;  /* size in bytes, for regular files */</span><br><span class="line">    struct timespec     st_atime; /* time of last access */</span><br><span class="line">    struct timespec     st_mtime; /* time of last modification */</span><br><span class="line">    struct timespec     st_ctime; /* time of last file status change */</span><br><span class="line">    blksize_t           st_blksize;/* best I/O block size */</span><br><span class="line">    blkcnt_t            st_blocks; /* number of disk blocks allocated */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; <strong>timespec结构</strong> 按照 <strong>秒</strong> 和 <strong>纳秒</strong> 定义了时间，包含以下两个成员：</p><blockquote><p><strong>time_t tv_sec;</strong><br><strong>long tv_nsec;</strong>  </p></blockquote><p>&emsp;&emsp;使用stat最多的地方应该是ls -l，可以获得一个文件的所有信息。</p><h1 id="三、文件类型"><a href="#三、文件类型" class="headerlink" title="三、文件类型"></a>三、文件类型</h1><p>&emsp;&emsp;①文件类型</p><blockquote><p>1、 <strong>普通文件（regular file）</strong> ：最常用的文件类型，这种文件包含某种格式的数据，至于是文本或二进制数据，对于Unix内核而言并无区别，对普通文件内容的解析由处理该文件的应用程序进行（例外是二进制可执行文件，为了执行程序，内核必须解析二进制文件，因此所有二进制可执行文件都有一个标准格式，才能保证内核找到程序和数据的加载位置）。<br>2、 <strong>目录文件（directory file）</strong> ：目录其实也是一种文件，它包含了其它文件的名字以及指向这些文件有关信息的指针，任何具有读权限的进程都可以读取目录文件，但只有内核才可以直接写目录文件，进程必须使用特定函数才更改目录。<br>3、 <strong>块特殊文件（block special file）</strong> ：这种类型的文件提供对设备（如磁盘）带缓冲的访问，每次以固定的长度访问。<br>4、 <strong>字符特殊文件（block special file）</strong> ：这种类型的文件提供对设备不带缓冲的访问，每访问长度可变，系统中所有设备是块特殊文件或字符特殊文件。<br>5、 <strong>FIFO</strong>：这种类型的文件用于进程间通信，也被为命令管道。<br>6、 <strong>套接字（socket）</strong>：这种类型的文件用于进程间的网络通信。<br>7、 <strong>符号链接（symbolic link）</strong> ：这种类型的文件指向另一个文件。  </p></blockquote><p>&emsp;&emsp;②文件类型信息<br>包含在stat结构中的st_mode成员中，用下图中的宏来确定文件类型。</p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.1.PNG" alt="图片"></p><p>&emsp;&emsp;③实例程序：读取命令行，对每一个命令行参数打印其文件类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;   </span><br><span class="line">    int i; </span><br><span class="line">    struct stat buf;</span><br><span class="line">    char *ptr;</span><br><span class="line">    for(i=1; i&lt;argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         printf(&quot;%s:&quot;,argv[i]);</span><br><span class="line">        if(lstat(argv[i], &amp;buf) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            err_ret(&quot;lstat error&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(S_ISREG(buf.st_mode))</span><br><span class="line">            ptr = &quot;regular&quot;;</span><br><span class="line">         else if(S_ISDIR(buf.st_mode))</span><br><span class="line">            ptr = &quot;directory&quot;;</span><br><span class="line">        else if(S_ISCHR(buf.st_mode))</span><br><span class="line">            ptr = &quot;character special&quot;;</span><br><span class="line">        else if(S_ISBLK(buf.st_mode))</span><br><span class="line">            ptr = &quot;block special&quot;;</span><br><span class="line">        else if(S_ISFIFO(buf.st_mode))</span><br><span class="line">            ptr = &quot;fifo&quot;;</span><br><span class="line">        else if(S_ISLNK(buf.st_mode))</span><br><span class="line">            ptr = &quot;symbolic link&quot;;</span><br><span class="line">         else if(S_ISSOCK(buf.st_mode))</span><br><span class="line">            ptr = &quot;socket&quot;;</span><br><span class="line">        else</span><br><span class="line">            ptr = &quot;unknow mode&quot;;</span><br><span class="line">         printf(&quot;%s\n&quot;,ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释</strong>:<br>行10：使用stat函数获取文件信息，而不是stat的原因是以便检测符号链接。<br>行15-30：使用宏S_ISxxx检测是哪种类型的文件。  </p></blockquote><blockquote><p><strong>执行命令</strong>：<br>/a.out /etc/passwd /etc /dev/log /dev/tty /var/lib/oprofile/opd_pipe /dev/sr0 /dev/cdrom   </p></blockquote><blockquote><p><strong>结果</strong>：<br>/etc/passwd:regular<br>/etc:directory<br>/dev/log:symbolic link<br>/dev/tty:character special<br>/var/lib/oprofile/opd_pipe:lstat error: No such file or directory<br>/dev/sr0:block special<br>/dev/cdrom:symbolic link<br><strong>小知识：在命令行末端加入”\”可在第二行继续输入当前命令</strong>。  </p></blockquote><p>&emsp;&emsp;④不同类型文件的一个统计值</p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.2.PNG" alt="图片"></p><p>&emsp;&emsp;可见 <strong>普通文件</strong> 是最主要的类型。</p><h1 id="四、设置用户ID和组ID"><a href="#四、设置用户ID和组ID" class="headerlink" title="四、设置用户ID和组ID"></a>四、设置用户ID和组ID</h1><p>&emsp;&emsp;与一个进程相关联的ID有6个或更多（对于进程而言）：</p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.3.PNG" alt="图片"></p><blockquote><pre><code>1、 **实际用户ID和实际组ID**：取值为口令文件中的登录项，通常在一个登录会话期间这些值并不改变，但是超级用户进程可以改变（进程最初执行时所用ID）。  2、 **有效用户ID、有效组ID和附属组ID**：进程执行时对文件的访问权限（进程实际执行中所用ID）。  </code></pre><p>   3、 <strong>保存的设置用户ID和保存的设置组ID</strong>：这个概念涉及到可执行程序文件的设置用户ID位，当可执行程序文件passwd的设置用户ID位(s)已经设置时，非root用户进程(exec)启动passwd程序，则该进程的有效用户ID和保存的设置用户ID都将被设置为这个可执行程序文件的所有者(即root)，也就是暂时可以用root的权限来访问文件了。<br>    4、 <strong>通常有效用户ID等于实际用户ID，有效组ID等于实际组ID</strong>。<br>    5、 <strong>每个文件有一个所有者和组所有者，分别由st_uid和st_gid指定</strong>。  </p></blockquote><h1 id="五、文件访问权限"><a href="#五、文件访问权限" class="headerlink" title="五、文件访问权限"></a>五、文件访问权限</h1><p>&emsp;&emsp;①    st_mode值（文件模式）包含了对文件的访问权限位（对于文件而言）：</p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.4.PNG" alt="图片"></p><blockquote><pre><code>1、当用路径访问一个文件时，每个目录都应该都具有执行权限。  2、目录的执行权限与读权限有区别，读权限允许读目录获取该目录的所有文件列表，执行权限是要执行一个文件时，该文件所在目录需要的权限。  3、对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作，这与open函数的O_RDONLY和O_RDWR标志有关。  4、对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作，这与open函数的O_WRONLY和O_RDWR标志有关。  5、为了在open函数中对一个文件指定O_TRUNC标志，必须对该文件具有写权限。  6、为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限。  7、问了在一个目录中删除一个文件，必须对包含该文件的目录具有写权限和执行权限，对该文件本身的权限并不关心。   8、如果用7个exec函数中任何一个执行某文件，都必须对该文件具有执行权限，该文件必须是一个普通文件。  </code></pre></blockquote><p>&emsp;&emsp;②    进程每次打开、新建或删除一个文件时，内核将对该文件进行访问权限测试，文件的所有者（st_uid和st_gid）是文件的性质；有效用户ID、有效组ID和附属组ID则是进程的性质。</p><blockquote><pre><code>1、若进程的有效用户ID是0（即超级用户），则允许访问。  2、若进程的有效用户ID等于文件所有者ID（即进程拥有此文件），那么如果所有者适当的访问权限位被设置，则允许访问，否则禁止访问。  3、若进程的有效组ID或附属组ID之一等于文件的组ID，那么如果所有者适当的访问权限位被设置，则允许访问，否则禁止访问。  4、若其它用户适当的访问权限位被设置，则允许访问，否则禁止访问。  </code></pre></blockquote><p>&emsp;&emsp;以上4个步骤顺序执行。  </p><h1 id="六、新文件和目录的所有权"><a href="#六、新文件和目录的所有权" class="headerlink" title="六、新文件和目录的所有权"></a>六、新文件和目录的所有权</h1><p>&emsp;&emsp;使用open和create函数创建新文件时，并没有设置文件的用户ID和组ID，以后学习mkdir函数时就会了解到如何创建一个新目录，并设置所有权规则。 <strong>新文件的用户ID将设置为进程的有效用户ID，而组ID将设置为进程的有效组ID或者它所在目录的组ID</strong>。</p><h1 id="七、函数access和faccessat"><a href="#七、函数access和faccessat" class="headerlink" title="七、函数access和faccessat"></a>七、函数access和faccessat</h1><p>&emsp;&emsp;当用open函数打开一个文件时，内核以进程的有效用户ID和有效组ID为基础进行访问测试，有时进程也希望按实际用户ID和实际组ID进行访问测试<br>&emsp;&emsp;①    函数作用：按实际用户ID和实际组ID进行访问测试。<br>&emsp;&emsp;②    函数原型  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int access(const char *pathname, int mode);</span><br><span class="line">int faccessat(int fd, const char *pathname, int mode, int flag);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;返回值：0-成功，-1-失败。  </p><blockquote><p><strong>mode参数</strong>：R_OK-测试读权限，W_OK-测试写权限，X_OK-测试执行权限。<br><strong>flag参数</strong>：改变faccessat的行为，取值为AT_EACCESS时，访问检查用的是调用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID。  </p></blockquote><h1 id="八、函数umask"><a href="#八、函数umask" class="headerlink" title="八、函数umask"></a>八、函数umask</h1><p>&emsp;&emsp;①    函数作用：每个文件都有9个访问权限位，为进程设置st_mode创建屏蔽字，并返回之前的值。<br>&emsp;&emsp;②    函数原型  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">mode_t umask(mode_t, cmask);</span><br></pre></td></tr></table></figure><blockquote><p>cmask参数：由五①图中9个常量相”或”组成。</p></blockquote><p>&emsp;&emsp;③    程序示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &quot;fcntl.h&quot;</span><br><span class="line"></span><br><span class="line">#define RWRWRW (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    umask(0);</span><br><span class="line">    if(creat(&quot;foo&quot;, RWRWRW) &lt; 0)</span><br><span class="line">        err_sys(&quot;creat error for foo&quot;);</span><br><span class="line"></span><br><span class="line">    umask(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);</span><br><span class="line">    if(creat(&quot;bar&quot;, RWRWRW) &lt; 0)</span><br><span class="line">        err_sys(&quot;creat error for foo&quot;);</span><br><span class="line"></span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行(%表示shell响应)：</strong>:<br>umask<br>%002<br>./a.out<br>ls -l foo bar<br>%-rw——- 1 sar 0 dec 7 21:20 bar<br>%-rw-rw-rw- 1 sar 0 dec 7 21:20 foo<br>umask<br>%002  </p></blockquote><p>&emsp;&emsp;④    umask文件访问权限位  </p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.5.PNG" alt="图片"></p><p>&emsp;&emsp;⑤    umask命令  </p><blockquote><p>umask–打印当前屏蔽字<br>umask -S–打印符号格式的屏蔽字<br>umask xxxx–修改屏蔽字  </p></blockquote><h1 id="九、函数chmod、fchmod和fchmodat"><a href="#九、函数chmod、fchmod和fchmodat" class="headerlink" title="九、函数chmod、fchmod和fchmodat"></a>九、函数chmod、fchmod和fchmodat</h1><p>&emsp;&emsp;①    函数作用：更改现有文件的访问权限。<br>&emsp;&emsp;②    函数原型  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int chmod(const char *pathname, mode_t mode);</span><br><span class="line">int fchmod(int fd, mode_t mode);</span><br><span class="line">int fchmodat(int fd, const char *pathname, mode_t mode, int flag);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;返回值：0-成功，-1-失败。  </p><blockquote><p><strong>参数mode</strong>：下图常量按位或</p></blockquote><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.6.PNG" alt="图片"></p><h1 id="十、粘着位"><a href="#十、粘着位" class="headerlink" title="十、粘着位"></a>十、粘着位</h1><p>&emsp;&emsp;如果可执行程序的这一位被设置，那么该程序第一次被执行，在其终止时， <strong>程序正文（机器指令）的一个副本仍保存在交换区，使得下一次执行改程序时可以很快的载入内存</strong> ，因此称为”粘着”，也就有了 <strong>常量S_ISVTX</strong> ，但当今Unix系统大多数都配置了 <strong>虚拟存储系统</strong> 以及 <strong>快速文件系统</strong> ，因此不再需要使用这项技术。</p><h1 id="十一、函数chown、fchown、fchownat和lchown"><a href="#十一、函数chown、fchown、fchownat和lchown" class="headerlink" title="十一、函数chown、fchown、fchownat和lchown"></a>十一、函数chown、fchown、fchownat和lchown</h1><p>&emsp;&emsp;①    函数作用：更改文件的用户ID和组ID，如果参数owner和group有一个为-1，则对应的ID不变。<br>&emsp;&emsp;②    函数原型  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int chown(const char *path, uid_t owner, gid_t group);</span><br><span class="line">int fchown(int fd, uid_t owner, gid_t group);</span><br><span class="line">int lchown(const char *path, uid_t owner, gid_t group);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;返回值：0-成功，-1-失败。</p><h1 id="十二、文件长度"><a href="#十二、文件长度" class="headerlink" title="十二、文件长度"></a>十二、文件长度</h1><p>&emsp;&emsp;①    stat结构中的 <strong>成员st_size</strong> 表示单位为字节的文件长度，此字段只对 <strong>普通文件、目录文件和符号链接</strong> 有意义。</p><blockquote><pre><code>1、 **普通文件**：文件长度可以是0，开始读这种文件时，将得到文件结束标志。  2、 **目录文件**：文件长度是16/512的整倍数。  3、 **符号链接**：文件长度等于路径名的字符长度。  </code></pre></blockquote><p>&emsp;&emsp;②     大多数现代Unix系统提供字段 <strong>st_blksize和st_blocks</strong> ，前一个是指 <strong>对文件I/O较合适的块长度</strong> ，后一个是指 <strong>分配的实际512字节块数</strong>。</p><h1 id="十三、文件截断"><a href="#十三、文件截断" class="headerlink" title="十三、文件截断"></a>十三、文件截断</h1><p>&emsp;&emsp;有时需要在文件尾端处截去一些数据以缩短文件，将文件长度截断为0是一个特例，在打开文件时使用O_TRUNC可以实现这一点，为了截断文件可以使用函数truncate和fturncoat。<br>&emsp;&emsp;函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int truncate(const char *pathname, off_t length);</span><br><span class="line">int ftruncate(int fd, off_t length);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;函数作用：将一个现有文件长度截断为length，如果该文件以前长度大于length，则超过以外的数据就不能再访问，如果小于length，文件长度将增加，新增长度的数据为0。</p><h1 id="十四、文件系统"><a href="#十四、文件系统" class="headerlink" title="十四、文件系统"></a>十四、文件系统</h1><p>&emsp;&emsp;①    可以把一个磁盘分为一个或多个分区，每个分区可包含一个文件系统，i节点是固定长度的记录项，它包含有关文件的大部分信息，此磁盘、分区和文件系统以及具体的柱面组的i节点和数据块示意图如下：</p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.7.PNG" alt="图片"><br><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.8.PNG" alt="图片"></p><p>&emsp;&emsp;②    <strong>i节点</strong> 包含了文件的所有信息，文件类型、文件访问权限位、文件长度和指向文件数据块的指针等，有两项数据存放在目录项中， <strong>文件名和i节点编号（数据类型为ino_t）</strong>。</p><p>&emsp;&emsp;③    对于Linux系统，链接分为两种，分别是硬链接和符号链接，默认ln命令产生硬链接。</p><blockquote><p><strong>硬链接</strong>：硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是 <strong>允许一个文件拥有多个有效路径名（在stat结构中，链接计数包含在st_nlink成员中，基本系统数据类型为nlink_t，LINK_MAX限制了链接数的最大值）</strong> ，这样用户就可以建立硬连接到重要文件，有防止 <strong>“误删”</strong> 的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。 <strong>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除</strong> 。</p></blockquote><blockquote><p><strong>符号链接</strong>：另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有 <strong>类似于Windows的快捷方式</strong> 。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p></blockquote><h2 id="具体未搞懂"><a href="#具体未搞懂" class="headerlink" title="具体未搞懂"></a><strong><em>具体未搞懂</em></strong></h2><h1 id="十五、函数link、linkat、unlink、unlinkat和remove"><a href="#十五、函数link、linkat、unlink、unlinkat和remove" class="headerlink" title="十五、函数link、linkat、unlink、unlinkat和remove"></a>十五、函数link、linkat、unlink、unlinkat和remove</h1><p>&emsp;&emsp;①link、linkat函数作用：创建一个指向现有文件的链接。<br>&emsp;&emsp;函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int link(const char *existingpath, const char *newpath);</span><br><span class="line">int linkat(int efd, const char *existingpath, const char *newpath, int flag);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;②unlink、unlinkat函数作用：删除一个现有的目录项。<br>&emsp;&emsp;函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int unlink(const char *pathname);</span><br><span class="line">int unlinkat(int fd, const char *pathname, int flag);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;③remove函数作用：解除对一个文件或目录的链接。<br>&emsp;&emsp;函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int remove(const char *pathname);</span><br></pre></td></tr></table></figure><blockquote><p>对于文件–remove与unlink功能相同。<br>对于目录–remove与rmdir功能相同。</p></blockquote><p>&emsp;&emsp;④实例程序如下：打开一个文件，然后解除它的链接，睡眠15s后终止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    if(open(&quot;tempfile&quot;, O_RDWR) &lt; 0)</span><br><span class="line">        err_sys(&quot;open error&quot;);</span><br><span class="line">    if(unlink(&quot;tempfile&quot;) &lt; 0)</span><br><span class="line">        err_sys(&quot;unlink error&quot;);</span><br><span class="line">    printf(&quot;unlink ok\n&quot;);</span><br><span class="line">    sleep(15);</span><br><span class="line">    printf(&quot;done\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>执行(%表示shell响应)：</strong><br>ls -l tempfile    查看文件大小<br>%-rw-r–r– 1 yanwn yanwn 10974 9月   4 06:30 tempfile  </p><p>df /home    检查可用空间<br>%文件系统          1K-块    已用     可用 已用% 挂载点<br>%/dev/sda1      20509264 8004032 11440376   42% /  </p><p>./a.out &amp;    后台运行<br>%3088    进程号<br>% unlink ok  </p><p>ls -l tempfile    观察文件是否还存在<br>% ls: 无法访问’tempfile’: 没有那个文件或目录    目录项已经被删除  </p><p>df /home    再次检查可用空间<br>%文件系统          1K-块    已用     可用 已用% 挂载点<br>%/dev/sda1      20509264 8004032 11440376   42% /<br>%done    15s过后，进程结束  </p><p>df /home    最后检查可用空间<br>%文件系统          1K-块    已用     可用 已用% 挂载点<br>%/dev/sda1      20509264 8004024 11440384   42% /  </p></blockquote><p>&emsp;&emsp; <strong>分析：unlink这种特点经常用来确保程序崩溃时，它所创建的临时文件也不会被保存下来，进程用open或create创建一个文件，然后调用unlink，因为该文件是打开的，所以不会被删除，只有当进程关闭该文件或终止时（内核关闭该进程打开的所有文件），该文件的内容将会被清除。如果pathname是符号链接，那么unlink删除的是本身，而不是该链接指向的文件，任何函数都不能删除链接所指向的文件。</strong></p><h1 id="十六、函数rename和renameat"><a href="#十六、函数rename和renameat" class="headerlink" title="十六、函数rename和renameat"></a>十六、函数rename和renameat</h1><p>&emsp;&emsp;函数作用：对文件或目录重命名。<br>&emsp;&emsp;函数原型：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int rename(const char *oldname, const char *newname)</span><br><span class="line">int renameat(int oldfd, const char *oldname, int newfd, const char *newname);</span><br></pre></td></tr></table></figure><h1 id="十七、符号链接"><a href="#十七、符号链接" class="headerlink" title="十七、符号链接"></a>十七、符号链接</h1><p>&emsp;&emsp;①符号链接是一个文件的间接指针，以下为各个函数对符号链接的处理情况示意图：<br><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/4.9.PNG" alt="图片"></p><p>&emsp;&emsp;②函数symlink和symlinkat用于创建一个符号链接，readlink和readlinkat用于打开链接本身，并读取链接地址。<br>&emsp;&emsp;函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int symlink(const char*actualpath,const char *sympath);</span><br><span class="line">int symlinkat(const char *actualpath,int fd,const char *sympath);</span><br><span class="line">ssize_t readlink(const char* restrict pathname,char *restrict buf,size_t bufsize);</span><br><span class="line">ssize_t readlinkat(int fd,const char* restrict pathname,char *restrict buf,size_t bufsize);</span><br></pre></td></tr></table></figure><blockquote><pre><code>1、symlink函数创建了一个指向actualpath的新目录项sympath。在创建此符号链接时，并不要求actualpath已经存在。并且actualpath和sympath并不需要位于同一文件系统中。  2、symlinkat函数与symlink函数类似，但sympath参数根据相对于打开文件描述符引用的目录(由fd指定)进行计算。如果sympath参数指定的是绝对路径或者fd参数设置了AT_FDCWD值，那么symlinkat就等同于symlink函数。  3、readlink和readlinkat函数组合了open、read和close的所有操作。如果函数成功执行，则返回读入buf的字节数。在buf中返回的符号链接的内容不以null字符终止。  4、当pathname参数指定的是绝对路径名或者fd参数的值为AT_FDCWD，readlinkat函数的行为与readlink相同。但是，如果fd参数是一个打开目录的有效文件描述符并且pathname参数是相对路径名，则readlinkat计算相对于由fd代表的打开目录的路径。  </code></pre></blockquote><h1 id="十八、-文件时间及相关函数"><a href="#十八、-文件时间及相关函数" class="headerlink" title="十八、    文件时间及相关函数"></a>十八、    文件时间及相关函数</h1><h2 id="暂时忽略"><a href="#暂时忽略" class="headerlink" title="暂时忽略"></a><strong><em>暂时忽略</em></strong></h2><h1 id="十九、-函数mkdir、mkdirat和rmdir"><a href="#十九、-函数mkdir、mkdirat和rmdir" class="headerlink" title="十九、    函数mkdir、mkdirat和rmdir"></a>十九、    函数mkdir、mkdirat和rmdir</h1><p>&emsp;&emsp;函数作用：mkdir、mkdirat用于创建目录，rmdir用于删除空目录。<br>&emsp;&emsp;函数原型：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int mkdir(const char *pathname, mode_t mode);</span><br><span class="line">int mkdirat(int fd, const char *pathname, mode_t mode);</span><br><span class="line">int rmdir(const char *pathname);</span><br></pre></td></tr></table></figure><h1 id="二十、函数chdir、fchdir"><a href="#二十、函数chdir、fchdir" class="headerlink" title="二十、函数chdir、fchdir"></a>二十、函数chdir、fchdir</h1><p>&emsp;&emsp;每个进程都有一个当前工作目录，当用户登录Unix系统时，其当前工作目录通常是口令文件（/etc/passwd）中登录项的第6个字段–用户的起始目录。 <strong>当前工作目录是进程的一个属性，起始目录是登录名的一个属性</strong> 。<br>&emsp;&emsp;函数作用：更改当前工作目录 <strong>（只影响调用进程的本身）</strong> 。<br>&emsp;&emsp;函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int chdir(constchar*pathname);</span><br><span class="line">int fchdir(int fd);</span><br></pre></td></tr></table></figure><h1 id="二十一、设备特殊文件"><a href="#二十一、设备特殊文件" class="headerlink" title="二十一、设备特殊文件"></a>二十一、设备特殊文件</h1><p>&emsp;&emsp;st_dev和st_rdev这两个字段容易混淆：</p><blockquote><pre><code>1、每个文件系统所在的存储设备都由 **主、次设备号** 表示，设备号所用数据类型为dev_t, **主设备号标识设备驱动程序，有时编码为与其通信的外设板，次设备标识特定的子设备** ，一个磁盘驱动器通常包含多个文件系统，在同一磁盘上各文件系统的主设备号通常相同，但次设备号不同。  2、用 **宏major和minor** 来访问主、次设备号。  3、 **系统中每个文件名关联的st_dev值是文件系统的设备号** 。  </code></pre><p>   4、 <strong>只有字符文件和块文件才有st_rdev值，此值包含实际设备的设备号</strong> 。  </p></blockquote><h1 id="二十二、小结"><a href="#二十二、小结" class="headerlink" title="二十二、小结"></a>二十二、小结</h1><p>&emsp;&emsp;本文围绕stat函数，学习了stat结构中的每一个成员，了解了Unix文件和目录的各个属性，学习了有关于文件和目录的大部分函数。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unix笔记2—文件I/O</title>
      <link href="/2018/09/02/Linux2/"/>
      <url>/2018/09/02/Linux2/</url>
      <content type="html"><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>&emsp;&emsp;①可用的 <strong>文件I/O函数</strong> ：打开文件、读文件、写文件。<br>&emsp;&emsp;②常用5个函数： <strong>open、read、write、lseek、close</strong> （不同缓冲长度影响将不同）。<br>&emsp;&emsp;③ <strong>不带缓冲I/O</strong> 是指每个read、write都调用内核中的一个系统函数，需要传入缓存区参数。<br>&emsp;&emsp;④ <strong>原子操作</strong> 及 <strong>dup、fcntl、sync、fsync、ioctl</strong> 函数。 </p><h1 id="二、文件描述符"><a href="#二、文件描述符" class="headerlink" title="二、文件描述符 "></a>二、文件描述符 </h1><p>&emsp;&emsp;①当打开一个现有文件或创建一个新文件时，内核向进程返回一个 <strong>文件描述符</strong> ，文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的 <strong>索引</strong> ，其值是一个非负整数，用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符，程序刚刚启动的时候：</p><blockquote><p><strong>0是标准输入（STDIN_FILENO）<br>1是标准输出（STDOUT_FILENO）<br>2是标准错误（STDERR_FILENO）</strong><br>如果此时去打开一个新的文件，它的文件描述符会是3。  </p></blockquote><p>&emsp;&emsp;②文件描述符变化范围： <strong>0~OPEN_MAX-1</strong> 。</p><h1 id="三、函数open和openat"><a href="#三、函数open和openat" class="headerlink" title="三、函数open和openat"></a>三、函数open和openat</h1><p>&emsp;&emsp;①open、openat打开/创建文件，成功则返回文件描述符，失败返回-1。<br>&emsp;&emsp;②open、opena函数原型。<br>&emsp;&emsp; <strong>#include&lt;fcntl.h&gt;</strong><br>&emsp;&emsp; <strong>int open(const char *path, int oflags, …, mode_t mode);</strong><br>&emsp;&emsp; <strong>int openat(int fd, const char *path, int oflags, …, mode_t mode);</strong><br>&emsp;&emsp;path-路径名（绝对路径）或者文件名（相对路径）。<br>&emsp;&emsp;oflags-打开文件采取的动作</p><blockquote><p>以下是必选参数（只能一个）：<br>O_RDONLY(只读)<br>O_WRONLY（只写）<br>O_RDWR（可读可写）  </p></blockquote><blockquote><p>以下是可选参数：<br>O_APPEND(每次写操作都写入文件的末尾)<br>O_CREAT(如果指定文件不存在，则创建这个文件)<br>O_EXCL(如果要创建的文件已存在，则返回-1，并且修改errno的值)<br>O_TRUNC(如果文件存在，并且以只写/读写方式打开，则清空文件全部内容)<br>O_NOCTTY(如果路径名指向终端设备，不要把这个设备用作控制终端)<br>O_NONBLOCK(如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继I/O设置为非阻塞模式(nonblocking mode))  </p></blockquote><p>&emsp;&emsp;fd-区别open、openat，有3种可能性:  </p><blockquote><p>path是绝对路径名，此时fd无用，open=openat。<br>path是相对路径名，fd指定相对路径起始。<br>path是相对路径名，fd=AT_FDCWD，相对路径起始=当前工作目录。  </p></blockquote><p>&emsp;&emsp;③open、openat函数返回的文件描述符一定是最小未用的。<br>&emsp;&emsp;④openat可以让线程使用相对路径名打开目录中的文件，而不受限于当前目录。  </p><h1 id="四、函数creat"><a href="#四、函数creat" class="headerlink" title="四、函数creat"></a>四、函数creat</h1><p>&emsp;&emsp;①creat函数用于创建新文件，成功则返回文件描述符，失败返回-1。<br>&emsp;&emsp;②creat函数原型。<br>&emsp;&emsp; <strong>int creat (const char *path, mode_t mode);</strong><br>&emsp;&emsp;③类似于open。  </p><h1 id="五、函数close"><a href="#五、函数close" class="headerlink" title="五、函数close"></a>五、函数close</h1><p>&emsp;&emsp;①close函数用于关闭文件，成功则返回文件描述符，失败返回-1。<br>&emsp;&emsp;②close函数原型。<br>&emsp;&emsp; <strong>int close(int fd);</strong><br>&emsp;&emsp;③当一个进程终止时，内核自动关闭它打开的所有文件。  </p><h1 id="六、函数lseek"><a href="#六、函数lseek" class="headerlink" title="六、函数lseek"></a>六、函数lseek</h1><p>&emsp;&emsp;①lseek用于使光标偏移，成功则返回新的偏移量（初始默认为0），失败返回-1。<br>&emsp;&emsp;②lseek函数原型。<br>&emsp;&emsp; <strong>off_t lseek(int fd, off_t offset, int whence);</strong>  </p><blockquote><p>whence=SEEK_SET，该文件偏移至文件开始处offset个字节。<br>whence=SEEK_CUR，该文件偏移至当前偏移量加offset。<br>whence=SEEK_END，该文件偏移至当文件长度加offset。  </p></blockquote><p>&emsp;&emsp;③检测当前偏移量 <strong>off_t currpos = lseek(fd, 0, SEEK_CUR);</strong><br>&emsp;&emsp;④检测标准输入能否设置偏移量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    if(lseek(STDIN_FILENO, 0, SEEK_CUR) == -1)</span><br><span class="line">        printf(&quot;cannot seek!&quot;);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;seek OK!&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;应该测试返回值是否为-1，而不是&lt;0，因为某些设备允许负的偏移量，文件偏移量可以大于文件的当前长度。</p><h1 id="七、函数read"><a href="#七、函数read" class="headerlink" title="七、函数read"></a>七、函数read</h1><p>&emsp;&emsp;①read函数用于打开文件读数据,成功返回字节数，到达文件尾返回0，失败返回-1。<br>&emsp;&emsp;②read函数原型。<br>&emsp;&emsp; <strong>ssize_t read(int fd, void *buf, size_t nbytes);</strong> </p><h1 id="八、函数write"><a href="#八、函数write" class="headerlink" title="八、函数write"></a>八、函数write</h1><p>&emsp;&emsp;①write函数用于打开文件写数据，成功返回写入字节数，失败返回-1。<br>&emsp;&emsp;②write函数原型。<br>&emsp;&emsp; <strong>ssize_t write(int fd, const void *buf, size_t nbytes);</strong><br>&emsp;&emsp;③write返回值通常等于nbytes，它的一个出错原因是磁盘被写满，或者超过了给定一个进程的文件长度限制。<br>&emsp;&emsp;④对于普通文件，写操作从当前偏移量开始，如果打开文件指定了O_APPEND选项，则每次写操作前，将文件偏移量设置到文件尾端，一次写成功后，该文件偏移量增加实际写的字节数。  </p><h1 id="九、I-O的效率"><a href="#九、I-O的效率" class="headerlink" title="九、I/O的效率"></a>九、I/O的效率</h1><p>&emsp;&emsp;①只使用write和read函数将标准输入复制到标准输出。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#define BUFFSIZE 4096</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    char buf[BUFFSIZE];</span><br><span class="line">    while((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0)</span><br><span class="line">        if(write(STDIN_FILENO, buf, n) != n)</span><br><span class="line">            err_sys(&quot;write error!&quot;);</span><br><span class="line">    if(n&lt;0)</span><br><span class="line">        err_sys(&quot;read error!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;②磁盘块长度由 <strong>st_blksize</strong> 表示，缓冲区 <strong>BUFFSIZE</strong> 使用4096（等于st_blksize）时，进程使用系统CPU时间最短。</p><h1 id="十、文件共享"><a href="#十、文件共享" class="headerlink" title="十、文件共享"></a>十、文件共享</h1><p>&emsp;&emsp;①Unix系统支持不同进程间共享打开文件 <strong>（多个进程同时读）</strong>。<br>&emsp;&emsp;②内核使用三种数据结构表示打开文件，分别是 <strong>文件描述符表</strong>、 <strong>文件表</strong>和 <strong>V节点表</strong>。<br>&emsp;&emsp;每个 <strong>进程</strong> 在 <strong>进程表</strong>中都有一个 <strong>记录项</strong>，记录项中包含一张 <strong>打开文件描述符表</strong> ，每个描述符占用一项。与每个文件描述符相关联的是：</p><blockquote><p>(a)    文件描述符标志。<br>(b)    指向一个文件表项的指针。  </p></blockquote><p>&emsp;&emsp;内核为所有打开文件维持一张 <strong>文件表</strong> ，每个文件表项包含:  </p><blockquote><p>(a)    文件状态标志(读、写、添写、同步和非阻塞等)。<br>(b)    当前文件偏移量。<br>(c)    指向该文件 V 节点表项的指针。  </p></blockquote><p>&emsp;&emsp;每个打开文件都有一个v节点结构(v-node)，v节点包含了 <strong>文件类型</strong> 和对此文件进行各种操作的 <strong>函数指针</strong> 。v节点还包含了从磁盘读取的 <strong>i节点(i-node)</strong> 的信息，i节点信息包含了 <strong>文件的所有者、文件长度、文件所在的设备、指向文件的实际数据块在磁盘上所在位置的指针</strong> 等。<br>&emsp;&emsp;图1表示了三张表之间的关系，该进程有两个不同的打开文件，分别是标准输入和标准输出。</p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/3.1.PNG" alt="图片"></p><p> <strong>图1:一个进程打开两个文件的内核数据结构</strong></p><p>&emsp;&emsp;图2表示两个进程打开同一个文件的内核数据结构，假定第一个进程在文件描述符3上打开该文件，而另一个进程在文件描述符4上打开该文件，则打开该文件的 <strong>每个进程都得到一个文件表项</strong> ，但对一个给定的文件 <strong>只有一个v节点表项</strong>。</p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/3.2.PNG" alt="图片"></p><p> <strong>图2:两个进程打开一个文件的内核数据结构</strong>  </p><p>&emsp;&emsp;③对前面所述操作的进一步说明。</p><blockquote><p>(a)每个进程都有自己的对打开文件的 <strong>当前偏移量</strong>。<br>(b)在完成每个write后,在文件表项中的当前文件偏移量即增加所写的字节数。如果这使当前文件偏移量超过了当前文件长度，则在i节点表项中的当前文件长度被设置为当前文件偏移量。<br>(c)若一个文件用lseek定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为i节点表项中的当前文件长度。 <strong>（这与O_APPEND标志打开文件是不同的，使用lseek定位到文件尾端处后，下次调用write写数据不一定是写在该文件的真正尾端，因为lseek和write两个不是原子操作，中间可以有另一个进程已使文件长度变长了。）</strong><br>(d)如果用O_APPEND 标志打开了一个文件，则相应标志被设置到文件表项的文件状态标志中， <strong>每次对这种具有添写标志的文件执行写操作时，在文件表项中的当前文件偏移量首先被设置成i节点表项中的文件长度，这就使得每次写的数据都添加到文件的当前尾端处。</strong><br>(e)lseek 函数只修改文件表项中的当前文件偏移量，没有进行任何I/O操作。  </p></blockquote><p>&emsp;&emsp;④以上过程可使得多个进程同时 <strong>读取</strong> 同一个文件，每个进程都有它自己的文件表项和当前偏移量。  </p><h1 id="十一、原子操作"><a href="#十一、原子操作" class="headerlink" title="十一、原子操作"></a>十一、原子操作</h1><p>&emsp;&emsp;①任何多于一个函数调用的操作都不是原子操作，因为两个函数调用之间，内核有可能会临时挂起进程。<br>&emsp;&emsp;②Unix系统提供了一种原子操作方法，即在打开文件时设定 <strong>O_APPEND标志</strong> ，这样做使得每次写操作之前，都将进程的当前偏移量设置为文件尾端，于是每次写操作的时候就不用lseek函数了。<br>&emsp;&emsp;③函数pread和pwrite。<br>&emsp;&emsp;     调用pread相当于先调用lseek后再调用read，但调用pread时，此过程无法被打断，并且不更新当前文件偏移量。<br>&emsp;&emsp;     调用pwrite相当于先调用lseek后再调用write。<br>&emsp;&emsp;④ <strong>一般而言，原子操作是指由多步组成的一个操作，如果该操作原子的执行，则要么执行完所有步骤，要么一步也不执行，原子操作也就是能被打断的最小操作。</strong></p><h1 id="十二、函数dup和dup2"><a href="#十二、函数dup和dup2" class="headerlink" title="十二、函数dup和dup2"></a>十二、函数dup和dup2</h1><p>&emsp;&emsp;①两个函数均用来复制一个现有的文件描述符，成功返回新的文件描述符，失败返回-1。<br>&emsp;&emsp;②函数原型。<br>&emsp;&emsp; <strong>#include &lt;unistd.h&gt;</strong><br>&emsp;&emsp; <strong>int dup(int fd);</strong><br>&emsp;&emsp; <strong>int dup2(int fd, int fd2);</strong><br>&emsp;&emsp;③dup函数返回的一定是当前可用数值最小的文件描述符，dup2函数可以指定新的文件描述符。  </p><h1 id="十三、函数sync、fsync和fdatasync"><a href="#十三、函数sync、fsync和fdatasync" class="headerlink" title="十三、函数sync、fsync和fdatasync"></a>十三、函数sync、fsync和fdatasync</h1><p>&emsp;&emsp;①Unix系统实现设有高速缓冲区，大多数磁盘I/O都通过缓冲区进行，当我们向文件写入数据时，内核通常先将数据复制到缓冲区，然后排入队列，晚些时候再存入磁盘，这种方式成为延迟写，如果内核要重用缓冲区，它会把所有延迟写数据块写入磁盘。<br>&emsp;&emsp;②为了保证磁盘与缓冲区数据一致，Unix系统提供了sync、fsync和fdatasync函数。  </p><blockquote><p>sync函数：只是将修改后的数据排入写队列，然后返回，不等待写入磁盘。<br>fsync函数：只对文件描述符fd指定的文件起作用，并等待写入磁盘。<br>fdatasync函数：类似于fsync，但它只影响文件的数据部分和同步更新文件的属性。  </p></blockquote><h1 id="十四、函数fcntl"><a href="#十四、函数fcntl" class="headerlink" title="十四、函数fcntl"></a>十四、函数fcntl</h1><p>&emsp;&emsp;①用于改变已经打开文件的属性，成功返回由cmd决定，失败返回-1。<br>&emsp;&emsp;②函数原型。<br>&emsp;&emsp; <strong>#include &lt;fcntl.h&gt;</strong><br>&emsp;&emsp; <strong>int fcntl(int fd, int cmd, …/<em> int arg </em>/);</strong><br>&emsp;&emsp;cmd有11种取值，这里未列出。 </p><h1 id="十五、函数ioctl"><a href="#十五、函数ioctl" class="headerlink" title="十五、函数ioctl"></a>十五、函数ioctl</h1><p>&emsp;&emsp;①ioctl是设备驱动程序中对设备的I/O通道进行管理的函数，即对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等，需要驱动程序提供对ioctl的支持。<br>&emsp;&emsp;②函数原型。<br>&emsp;&emsp; <strong>#include &lt;sys/ioctl.h&gt;</strong><br>&emsp;&emsp; <strong>int ioctl(int d,int request,….);</strong> </p><h1 id="十六、小结"><a href="#十六、小结" class="headerlink" title="十六、小结"></a>十六、小结</h1><p>&emsp;&emsp;本文学习了文件描述符的定义和基本作用，以及Unix系统提供的基本I/O函数。在多个进程读取文件时，了解了文件共享机制，为了防止多个进程同时写同一文件带来的干扰，学习了原子操作，最后还学习了fcntl和ioctl函数。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unix笔记1—基础知识</title>
      <link href="/2018/08/30/Linux1/"/>
      <url>/2018/08/30/Linux1/</url>
      <content type="html"><![CDATA[<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>&emsp;&emsp;操作系统为所运行的程序提供服务，典型服务有：</p><blockquote><p>①执行新程序<br>②打开文件<br>③读取文件<br>④分配存储区<br>⑤获取系统时间  </p></blockquote><h1 id="二、Unix体系结构"><a href="#二、Unix体系结构" class="headerlink" title="二、Unix体系结构"></a>二、Unix体系结构</h1><p>&emsp;&emsp;操作系统是一种软件，它控制计算机系统资源，提供程序运行环境，通常称其为 <strong>内核（kernel）</strong> ,因为它相对较小，而且处于环境的核心。内核接口称为 <strong>系统调用，公用函数库</strong> 建立于系统调用之上，应用程序可以使用 <strong>系统调用</strong> 和 <strong>公用函数库</strong> , <strong>Shell</strong> 是一个特殊的应用程序，为运行其它应用程序提供一个接口。</p><h1 id="三、登录"><a href="#三、登录" class="headerlink" title="三、登录"></a>三、登录</h1><p>&emsp;&emsp;登录Unix时，必须键入 <strong>用户名</strong> 和 <strong>密码</strong> ，存在于 <strong>/etc/passwd</strong> 文件。</p><h1 id="四、shell"><a href="#四、shell" class="headerlink" title="四、shell"></a>四、shell</h1><p>&emsp;&emsp;shell是一个 <strong>命令行解释器</strong> ，它读取用户输入，然后执行命令，输入来自终端或者文件（shell脚本）。</p><h1 id="五、文件和目录"><a href="#五、文件和目录" class="headerlink" title="五、文件和目录"></a>五、文件和目录</h1><p>&emsp;&emsp;① <strong>文件系统</strong> 是目录和文件的一种层次结构，起点是根目录（root），符号为”\”。<br>&emsp;&emsp;② <strong>目录</strong> 是一个包含目录项的文件，目录项=文件名+文件属性，文件属性包含文件类型（普通文件/目录）、文件大小、文件所有者、文件权限及文件最后修改的时间。<br>&emsp;&emsp;③ <strong>文件名</strong> 是目录项中的各个名字，”/“和” “不能出现在文件名中，创建新目录是会自动创建两个文件名，分别是”.” <strong>当前目录</strong> 和”..” <strong>上一目录</strong> ，处于根目录时，”.”=”..”。<br>&emsp;&emsp;④ <strong>路径名</strong> 是由斜线分割的一个或多个文件名组成的序列，分别 <strong>绝对路径</strong> 和 <strong>相对路径</strong> 。<br>&emsp;&emsp;⑤ <strong>列出目录</strong> 中所有文件名的代码如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &quot;dirent.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) </span><br><span class="line">&#123;</span><br><span class="line">  DIR *dp;</span><br><span class="line">  struct dirent *dirp;</span><br><span class="line">  if(argc != 2)</span><br><span class="line">    err_quit(&quot;usage: ls directory_name&quot;);</span><br><span class="line">  if((dp = opendir(argv[1])) == NULL)</span><br><span class="line">    err_sys(&quot;can&apos;t open %s&quot;, argv[1]);</span><br><span class="line">  while((dirp = readdir(dp)) != NULL)</span><br><span class="line">    printf(&quot;%s\n&quot;,dirp-&gt;d_name);</span><br><span class="line">  closedir(dp);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释</strong> ：<br>行1：apue.h为作者自定义头文件，需先下载至系统。<br>行2：系统头文件，/user/include/dirent.h，可以使用 <strong>dirent</strong> 结构和 <strong>opendir</strong> 、 <strong>readdir</strong> 函数。<br>行4：ISO C风格的main函数声明， <strong>argc参数</strong> 是传入命令行的字符串数目， <strong>*argv[]</strong> 是具体的命令行字符。<br>行6：opendir将返回DIR结构指针。<br>行7：readdir将返回dirent结构指针。<br>行8、9：传入命令行字符串数目错误，输出提示信息。<br>行10、11：传入路径为空时，输出提示信息。<br>行12、13：读取每个目录项并打印。<br>行14：释放目录<br>行15：exit终止程序，参数0表示正常结束，1-255表示出错。  </p></blockquote><blockquote><p><strong>执行</strong> ：<br>使用 <strong>cc *.c</strong> 进行编译（cc=gcc），默认生成 <strong>a.out</strong> 文件，运行命令行 <strong>./a.out /dir</strong> ，即可列出dir目录下所有文件名，dir为所需目录名。</p></blockquote><h1 id="六、输入和输出"><a href="#六、输入和输出" class="headerlink" title="六、输入和输出"></a>六、输入和输出</h1><p>&emsp;&emsp;① <strong>文件描述符</strong> 是一个小的非负整数，内核用来标定一个特定进程正在访问的文件。当内核打开一个文件或创建一个文件时，它都返回一个文件描述符，在读/写文件时使用这个文件描述符。<br>&emsp;&emsp;② <strong>标准输入、标准输出、标准错误</strong><br>当运行一个新程序时，shell将打开以上三个文件描述符，一般这三个文件描述符都指向终端，shell可以将这些文件描述符重新定向到某个文件，如：ls&gt;file.list。<br>&emsp;&emsp;③ <strong>不带缓冲的I/O</strong><br>函数open、read、lseek、close提供了不带缓冲的I/O，这些函数都使用文件描述符。<br>&emsp;&emsp;④ <strong>复制任一Unix普通文件</strong> 代码如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#define BUFFSIZE 4096</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   int n;</span><br><span class="line">   char buf[BUFFSIZE];</span><br><span class="line">   while((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0)</span><br><span class="line">      if(write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">         err_sys(&quot;write error!&quot;);</span><br><span class="line">   if(n&lt;0)</span><br><span class="line">      err_sys(&quot;read error!&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释：</strong><br>行7、8、9：常量STDIN_FILENO和STDOUT_FILENO是POSIX标准的一部分，定义在&lt;unistd.h&gt;中，它们指定了标准输入和输出的文件描述符，值分别为0和1，read函数返回读取的字节数，读到文件尾端时将返回0，如果读错误将返回-1。  </p></blockquote><blockquote><p><strong>执行：</strong><br>./a.out &gt; data ：输入是终端（ctrl+D结束），输出是data文件。<br>./a.out <infile>outfile：输入是infile文件，输出是outfile文件。  </infile></p></blockquote><p>&emsp;&emsp;⑤ <strong>标准I/O</strong><br>标准I/O函数为那些不带缓冲的I/O函数提供了一个 <strong>带缓冲的接口</strong> ，使用标准I/O函数无需担心选取最佳缓冲区大小，标准I/O函数还简化了输入行的处理，例如：fgets函数读取一个完整的行，read函数读取指定字节数，printf是我们最熟悉的标准I/O函数之一，&lt;stdio.h&gt;包含了所有标准I/O函数的原型。<br>&emsp;&emsp;⑥ <strong>将标准输入复制到标准输出</strong> 代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   int c;</span><br><span class="line">   while((c = getc(stdin)) != EOF)</span><br><span class="line">      if(putc(c, stdout) == EOF)</span><br><span class="line">         err_sys(&quot;output error!&quot;);</span><br><span class="line">      if(ferror(stdin))</span><br><span class="line">         err_sys(&quot;input error!&quot;);</span><br><span class="line">      exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释：</strong><br>行5、6：函数getc一次读取一个字符，putc显示在屏幕上，常量EOF（end of file）定义在&lt;stdio.h&gt;中，表示文件结束标志（Ctrl+D），值为-1，stdin和stdout也定义在&lt;stdio.h&gt;，分别表示标准输入和标准输出。  </p></blockquote><blockquote><p><strong>执行：</strong><br>./a.out  </p></blockquote><h1 id="七、程序和进程"><a href="#七、程序和进程" class="headerlink" title="七、程序和进程"></a>七、程序和进程</h1><p>&emsp;&emsp;① <strong>程序</strong> 是存储在磁盘中的可执行文件，内核使用 <strong>exec</strong> 函数，将程序 <strong>读入内存</strong> ， <strong>并执行程序</strong> 。<br>&emsp;&emsp;② <strong>进程和进程ID</strong><br>程序的执行实例被称为 <strong>进程（process）</strong> ，某些操作系统用 <strong>任务（task）</strong> 表示正在被执行的程序，Unix系统确保每个进程都有一个唯一的数字标识符，成称为进程ID，它总是一个非负的整数。<br>&emsp;&emsp;③ <strong>打印进程ID号代码如下：</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;hello world form process ID %ld\n&quot;,(long)getpid());</span><br><span class="line">   exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释：</strong><br>getpid函数用于返回进程ID值，类型为pid_t类型。  </p></blockquote><blockquote><p><strong>执行：</strong><br>./a.out  </p></blockquote><p>&emsp;&emsp;④ <strong>进程控制。</strong><br>有3个用于进程控制的主要函数， <strong>fork、exec、waitpid（exec有7种变体）</strong><br>&emsp;&emsp;⑤ <strong>从标准输入读取命令并执行</strong> 代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &quot;sys/wait.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   char buf[MAXLINE];</span><br><span class="line">   pid_t pid;</span><br><span class="line">   int status;</span><br><span class="line">   printf(&quot;%% &quot;);</span><br><span class="line">   while(fgets(buf, MAXLINE, stdin) != NULL)</span><br><span class="line">   &#123;</span><br><span class="line">      if(buf[strlen(buf) - 1] == &apos;\n&apos;)</span><br><span class="line">      &#123;</span><br><span class="line">        buf[strlen(buf) - 1] = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if((pid = fork()) &lt; 0)</span><br><span class="line">      &#123;</span><br><span class="line">         err_sys(&quot;fork error!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      else if(pid == 0)</span><br><span class="line">      &#123;</span><br><span class="line">         execlp(buf, buf, (char*)0);</span><br><span class="line">         err_ret(&quot;couldn&apos;t execute: %s&quot;, buf);</span><br><span class="line">         exit(127);</span><br><span class="line">      &#125;</span><br><span class="line">      if((pid = waitpid(pid, &amp;status, 0)) &lt; 0)</span><br><span class="line">        err_sys(&quot;waitpid error&quot;);</span><br><span class="line">      printf(&quot;%% &quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   exit(0);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释：</strong><br>行12、13、14、15：因为fgets每一行都以换行符终止，而execlp函数要以null结尾，因此要替换一下。<br>行16：调用fork创建一个新进程，新进程是调用进程的一个副本，新进程称为 <strong>子进程</strong> ，调用进程称为 <strong>父进程</strong> ，fork对父进程返回子进程的ID，对子进程则返回0，fork调用一次，返回两次。<br>行22：子进程调用execlp（从PATH 环境变量中查找文件并执行， <strong>执行成功函数将不会返回，失败返回-1</strong> ）执行从标准输入的命令，用新的程序文件替换子进程原先执行的程序文件。<br>行27：父进程通过调用waitpid等待子进程执行完毕，其参数1指定要等待的进程，waitpid返回子进程的终止状态（status变量）。  </p></blockquote><p>&emsp;&emsp;⑥ <strong>线程和线程ID</strong><br>一个进程内的所有线程共享同一个地址空间、文件描述符、栈及其进程相关的属性，所以各线程需要采集同步措施，以避免不一致性，线程也有ID，但只在本身进程内起作用。  </p><h1 id="八、出错处理"><a href="#八、出错处理" class="headerlink" title="八、出错处理"></a>八、出错处理</h1><p>&emsp;&emsp;当Unix系统函数出错时，一般返回一个负值，而 <strong>整形变量errno</strong> 被设置为具有特定信息的值，文件&lt;errno.h&gt;定义了errno以及它可以被赋的值，POSIX和ISO C将errno定义为一个符号，它扩展为一个可修改的 <strong>整形左值</strong> ，它可以是一个包含出错编号的 <strong>整数</strong> ，也可以是一个返回出错编号指针的函数，使用应该注意两项：1、如果没有出错，其值不会被清除，因此当函数返回值表明错误时，才需要去检验其值。2、任何函数都不会将errno的值置0。<br>&emsp;&emsp;C标准定义了两个函数，用于打印出错信息。<br> <strong>#include &lt;string.h&gt;</strong><br> <strong>char *strerror(int errnum);</strong>   //返回错误字符串指针，通常errnum就是errno<br> <strong>#include &lt;stdio.h&gt;</strong><br> <strong>void perror(const char *msg);</strong>   //首先输出msg指向的字符串，然后添加冒号和空格，接着输出errno值的出错消息，最后换行。<br>实例代码如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">   fprintf(stderr, &quot;EACCES: %s\n&quot;,strerror(EACCES));</span><br><span class="line">   errno = ENOENT;</span><br><span class="line">   perror(argv[0]);</span><br><span class="line">   exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="九、用户标识"><a href="#九、用户标识" class="headerlink" title="九、用户标识"></a>九、用户标识</h1><p>&emsp;&emsp;① <strong>用户ID</strong> 是一个数值，用户ID为0的用户是 <strong>根用户</strong> 和 <strong>超级用户</strong> 。<br>&emsp;&emsp;② <strong>组ID</strong> 是一个数值，组用户用于将若干用户集合到项目或部门中去，这种机制允许同组的各个成员之间共享资源，组文件通常是/etc/group。<br>&emsp;&emsp;③ <strong>getuid</strong> 和 <strong>getgid</strong> 用于获取用户ID和组ID。<br>&emsp;&emsp;④ <strong>附属组ID</strong>。</p><h1 id="十、信号"><a href="#十、信号" class="headerlink" title="十、信号"></a>十、信号</h1><p>&emsp;&emsp;信号用于通知进程发生了某种情况，进程有以下三种方式处理：</p><blockquote><p>忽略信号<br>按系统默认方式处理<br>提供一个函数  </p></blockquote><p>很多情况都会产生信号，终端键盘有两种产生信号的办法，分别称为 <strong>中断键（Delete或Ctrl+C）</strong> 和 <strong>退出键（Ctrl+\）</strong> ，他们被用于终止当前运行的进程，另一种产生信号的办法是调用 <strong>kill函数</strong> ，在一个进程中调用此函数可向另一个进程发送信号，信号函数是 <strong>signal</strong> 。</p><h1 id="十一、时间值"><a href="#十一、时间值" class="headerlink" title="十一、时间值"></a>十一、时间值</h1><p>&emsp;&emsp;Unix使用过两种不同的时间值：  </p><blockquote><p><strong>日历时间：</strong> 该值来自UTC，1970-01-01 00:00:00，这个时间所经过的秒数值，系统基本数据类型 <strong>time_t</strong> 用于保存这种时间。<br><strong>进程时间：</strong> 也称为CPU时间，用以度量进程使用的中央处理器资源，以时钟滴答计算，系统基本数据类型 <strong>clock_t</strong> 保存这种时间，使用sysconf可以得到每秒时钟滴答数。  </p></blockquote><p>&emsp;&emsp;Unix系统为一个进程维护了三个进程时间值：  </p><blockquote><p><strong>时钟时间</strong>—进程运行的时间总量。<br><strong>用户CPU时间</strong>—执行用户指令所需时间。<br><strong>系统CPU时间</strong>—该进程执行内核程序所经历的时间。  </p></blockquote><h1 id="十二、小结"><a href="#十二、小结" class="headerlink" title="十二、小结"></a>十二、小结</h1><p>&emsp;&emsp;本文快速浏览了unix系统的全局，对Unix系统有了一个基本印象。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>433M无线模块组网应用</title>
      <link href="/2018/06/04/433M%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BD%91%E5%BA%94%E7%94%A8/"/>
      <url>/2018/06/04/433M%E6%97%A0%E7%BA%BF%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BD%91%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="一、无线模块的发展背景"><a href="#一、无线模块的发展背景" class="headerlink" title="一、无线模块的发展背景"></a>一、无线模块的发展背景</h1><p>&emsp;&emsp;传统的有线连接不仅成本高，而且在特殊场合时，布线安装困难，维护也不方便，不能满足智能行业的发展需求，因此无线的应用便得到了发展，而且肯定是今后的发展趋势。<br>&emsp;&emsp;在无线传输时，采用433M频段有什么优点呢？</p><blockquote><p>   1、433M是免费频段<br>   2、433M传输距离远<br>   3、433M抗干扰能力强<br>   4、433M在传输速度和绕射性能两个方面要相对平衡</p></blockquote><h1 id="二、无线组网的一主多从传输机制"><a href="#二、无线组网的一主多从传输机制" class="headerlink" title="二、无线组网的一主多从传输机制"></a>二、无线组网的一主多从传输机制</h1><p>&emsp;&emsp;无线组网应用中，如果只采用点对点收发数据的话，在很多场合都是不能满足要求的，因此便有了一主多从轮询的方式，该组网方式有着 <strong>准确上传、设备之间不容易发生冲突、组网稳定</strong> 的优点，但是当从设备数目较多时，轮询时间开销比较大，对于主机来说，功耗也比较大，这种方式只适用于对 <strong>时间和功耗要求不高</strong> 的组网场合。   </p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/1.1.png" alt="图片"></p><p>&emsp;&emsp;一主多从轮询机制原理很简单，即通过点名的方式实现应答，这就要求每个从设备要有一个地址，而且这个地址必须是唯一的。如主机发送命令给地址编号为1的从机，只有1号从机能够响应主机，将数据上传给主机，主机再以相同的方式轮询其它从机数据。  </p><p><img src="https://raw.githubusercontent.com/ywngithub/MyPostImage/master/1.2.png" alt="图片"></p><p>&emsp;&emsp;这种轮询机制原理相对简单，并且容易实现，但是效率很低，主机一直处于轮询状态，从机处于应答状态，主从机都一直处于工作状态，因此功耗无法降低，这种方式将不适用于太阳能供电或者电池供电的场合。</p><h1 id="三、低功耗无线组网"><a href="#三、低功耗无线组网" class="headerlink" title="三、低功耗无线组网"></a>三、低功耗无线组网</h1><p>&emsp;&emsp;低功耗无线组网采用分时间片的方式，具体实现如下：<br>&emsp;&emsp;首先，主机发起广播（所有从机均可收到），广播当前时间，所有从机时间同步后，主机再广播休眠时间，从机收到广播消息后，全部进入休眠模式，广播完成后，主机也进入休眠模式，当广播休眠定时时间到了后，主机和1号从机会被立刻唤醒，进入工作模式，从机上传数据，每个从机会根据地址进行延迟唤醒。例如：广播休眠时间t1=10s，数据传输时间t2=500ms，则1号机休眠时间为10s，上传数据时间为500ms，2号从机休眠时间为10.5s，上传数据时间为500ms，三号从机休眠时间为11s，上传数据时间为500ms，即</p><blockquote><p>从机休眠时间计算公式为：T = t1 + t2 * N<br>N：从机地址编号</p></blockquote><p>&emsp;&emsp;这种组网方式由于引入了休眠模式，避免了从机长时间处于应答状态，从而可以大大降低功耗，但是对主从机的时间精度要求较高。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>&emsp;&emsp;无线组网的方式有许许多多种，本文介绍了工程中常用的一主多从轮询机制，并且介绍了如何降低功耗及实现的基本原理。</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程应用 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
